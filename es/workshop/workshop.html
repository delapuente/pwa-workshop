
<!DOCTYPE HTML>
<html lang="es" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>Introducción · GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.2">
        
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
        <link rel="stylesheet" href="../styles/website.css">
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="workshop.html" />
    
    
    <link rel="prev" href="../" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Escribe para buscar" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        <li class="header">Taller</li>
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="workshop.html">
            
                <a href="workshop.html#intro">
            
                    
                    Introducción
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="workshop.html">
            
                <a href="workshop.html#service-workers">
            
                    
                    Uso básico de service workers
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="workshop.html">
            
                <a href="workshop.html#registering">
            
                    
                    Creación del fichero y registro
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="workshop.html">
            
                <a href="workshop.html#installation">
            
                    
                    Instalación y activación del service worker
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.3" data-path="workshop.html">
            
                <a href="workshop.html#cache-strategies">
            
                    
                    Estrategias de caché
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.4" data-path="workshop.html">
            
                <a href="workshop.html#service-workers-conclusion">
            
                    
                    Conclusión
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="workshop.html">
            
                <a href="workshop.html#web-manifest">
            
                    
                    El manifiesto web
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="workshop.html">
            
                <a href="workshop.html#web-manifest-conclusion">
            
                    
                    Conclusión
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="workshop.html">
            
                <a href="workshop.html#push-notifications">
            
                    
                    Notificaciones push
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.5.1" data-path="workshop.html">
            
                <a href="workshop.html#client-server">
            
                    
                    Estableciendo la comunicación cliente-servidor
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.2" data-path="workshop.html">
            
                <a href="workshop.html#sending-notifications">
            
                    
                    Enviando notificaciones a los clientes
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.3" data-path="workshop.html">
            
                <a href="workshop.html#showing-notifications">
            
                    
                    Mostrando la notificación al usuario
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.4" data-path="workshop.html">
            
                <a href="workshop.html#notification-action">
            
                    
                    Acción al pulsar en la notificación
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.5" data-path="workshop.html">
            
                <a href="workshop.html#push-notifications-conclusion">
            
                    
                    Conclusión
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    
        
        <li class="header">Guía del taller</li>
        
        
    
        <li class="chapter " data-level="2.1" >
            
                <span>
            
                    
                    Público
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="2.2" >
            
                <span>
            
                    
                    Duración
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="2.3" >
            
                <span>
            
                    
                    Equipamiento
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="2.4" >
            
                <span>
            
                    
                    Objetivo
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="2.5" >
            
                <span>
            
                    
                    Consideraciones adicionales
            
                </span>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Publicado con GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >Introducción</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h2 id="intro">Introducci&#xF3;n a la aplicaci&#xF3;n </h2>
<p><em>Recommendations</em> es una aplicaci&#xF3;n web pensada para mantener una lista de recomendaciones. Con <em>Recommendations</em> podemos marcar una recomendaci&#xF3;n como revisada o favorita.</p>
<hr>
<p><em>Recommendations</em> es un sitio web din&#xE1;mico a la vieja usanza: no contiene una sola l&#xED;nea de JavaScript en el cliente y depende &#xFA;nicamente de su servidor web <a href="https://nodejs.org/en/" target="_blank">Node.js</a>, basado en <a href="https://expressjs.com/" target="_blank">Express</a>. El servidor realiza la composici&#xF3;n de la lista de recomendaciones utilizando plantillas <a href="http://handlebarsjs.com/" target="_blank">handlebars</a>.</p>
<p>Por simplicidad, el servidor no posee gesti&#xF3;n de sesiones; tampoco forma alguna de persistencia y no proporciona una gesti&#xF3;n adecuada de los errores por lo que no debe considerarse su uso en producci&#xF3;n.</p>
<p>Esto implica que tendr&#xE9;is que <a href="https://glitch.com/~pwa-workshop" target="_blank">trabajar con vuestra propia remezcla del proyecto en Glitch</a> para no interferir unos con otros y que al modificar el fichero del servidor, este se reiniciar&#xE1; y <strong>se perder&#xE1;n todos los cambios en las recomendaciones</strong>.</p>
<h3 id="c&#xF3;digo-en-el-cliente">C&#xF3;digo en el cliente</h3>
<p>Para la comunicaci&#xF3;n con el servidor, la aplicaci&#xF3;n usa elementos <code>form</code> y el servidor responde realizando la operaci&#xF3;n pertinente y devolviendo siempre la lista de recomendaciones tomando como plantilla el fichero <code>views/index.html</code>. En este sentido, la aplicaci&#xF3;n puede considerarse <em>de una s&#xF3;la vista</em> pero no encaja en la definici&#xF3;n cl&#xE1;sica de <em>single page application</em> desde el momento en el que realmente navegamos a otras direcciones.</p>
<p>La lista posee dos tipos de formularios: uno en la cabecera para enviar una nueva recomendaci&#xF3;n y otro por cada recomendaci&#xF3;n para actualizar su estado.</p>
<p>El formulario para a&#xF1;adir una nueva recomendaci&#xF3;n contiene los campos para el t&#xED;tulo y el tipo de recomendaci&#xF3;n, y el bot&#xF3;n a&#xF1;adir, para enviar el formulario. Al enviarse, se realiza una petici&#xF3;n <code>POST</code> sobre <code>/recommendations</code>.</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;new-recommendation&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;POST&quot;</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/recommendations&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;offset title-area&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;title-input&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;title&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">required</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;title-input&quot;</span>&gt;</span>Enter new recommendation&amp;hellip;<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;type&quot;</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;movie&quot;</span>&gt;</span>movie<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;show&quot;</span>&gt;</span>show<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;music&quot;</span>&gt;</span>music<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;game&quot;</span>&gt;</span>game<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;reading&quot;</span>&gt;</span>reading<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;add-new&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">aria-label</span>=<span class="hljs-string">&quot;Add&quot;</span>&gt;</span>&amp;nbsp;<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
</code></pre>
<p>Cada recomendaci&#xF3;n contiene otro formulario, generado din&#xE1;micamente desde el servidor, que realiza una petici&#xF3;n <code>POST</code> sobre su <em>URL</em>, de la forma <code>/recommendations/&lt;id&gt;</code>.</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;POST&quot;</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/recommendations/{{id}}&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;custom-checkbox&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;status&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;unchecked&quot;</span> {{#<span class="hljs-attr">if</span> <span class="hljs-attr">unchecked</span>}}<span class="hljs-attr">checked</span>{{/<span class="hljs-attr">if</span>}} <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">aria-label</span>=<span class="hljs-string">&quot;I&apos;ve not checked it yet&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;custom-checkbox&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;status&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;checked&quot;</span> {{#<span class="hljs-attr">if</span> <span class="hljs-attr">checked</span>}}<span class="hljs-attr">checked</span>{{/<span class="hljs-attr">if</span>}} <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">aria-label</span>=<span class="hljs-string">&quot;I&apos;ve checked it&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;custom-checkbox&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;status&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;liked&quot;</span> {{#<span class="hljs-attr">if</span> <span class="hljs-attr">liked</span>}}<span class="hljs-attr">checked</span>{{/<span class="hljs-attr">if</span>}} <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">aria-label</span>=<span class="hljs-string">&quot;I liked it&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;update-item&quot;</span> <span class="hljs-attr">aria-label</span>=<span class="hljs-string">&quot;Save&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;OK!&quot;</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
</code></pre>
<h3 id="c&#xF3;digo-en-el-servidor">C&#xF3;digo en el servidor</h3>
<p>Como cualquier otra aplicaci&#xF3;n Express, el servidor es un conjunto de operaciones sobre rutas que emiten un resultado:</p>
<pre><code class="lang-js">app.get(<span class="hljs-string">&apos;/&apos;</span>, renderList);
app.get(<span class="hljs-string">&apos;/recommendations&apos;</span>, renderList);
app.get(<span class="hljs-string">&apos;/recommendations/:id&apos;</span>, renderList);

app.post(<span class="hljs-string">&apos;/recommendations&apos;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">request, response</span>) </span>{
  <span class="hljs-keyword">const</span> { type, title } = request.body;
  recommendations.push(newRecommendation(type, title));
  renderList(request, response);
});

app.post(<span class="hljs-string">&apos;/recommendations/:id&apos;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">request, response</span>) </span>{
  <span class="hljs-keyword">const</span> unchecked = request.body.status === <span class="hljs-string">&apos;unchecked&apos;</span>;
  <span class="hljs-keyword">const</span> checked = request.body.status === <span class="hljs-string">&apos;checked&apos;</span>;
  <span class="hljs-keyword">const</span> liked = request.body.status === <span class="hljs-string">&apos;liked&apos;</span>;
  <span class="hljs-keyword">const</span> index = find(<span class="hljs-built_in">parseInt</span>(request.params.id), recommendations);
  recommendations[index].unchecked = unchecked;
  recommendations[index].checked = checked;
  recommendations[index].liked = liked;
  renderList(request, response);
});
</code></pre>
<p>Tres operaciones <code>GET</code> gobiernan la visualizaci&#xF3;n de la lista y no realizan ninguna operaci&#xF3;n. Las operaciones <code>POST</code>, adem&#xE1;s de devolver la lista, realizan la gesti&#xF3;n de las recomendaciones.</p>
<p>La funci&#xF3;n <code>renderList</code> env&#xED;a la lista bas&#xE1;ndose en la plantilla <code>views/index.html</code>:</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderList</span> (<span class="hljs-params">request, response</span>) </span>{
  response.render(__dirname + <span class="hljs-string">&apos;/views/index.html&apos;</span>, {
    recommendations: sort(recommendations)
  });
}
</code></pre>
<h2 id="service-workers">1. Uso b&#xE1;sico de service workers </h2>
<p>Un <em>service worker</em> act&#xFA;a como un proxy de red ejecut&#xE1;ndose en el navegador: intercepta las peticiones HTTP que salen de nuestro sitio web hacia la red y puede contestar con cualquier tipo de contenido.</p>
<p>En esta primera lecci&#xF3;n, vamos a preparar nuestra aplicaci&#xF3;n para que funcione incluso sin conexi&#xF3;n a la red.</p>
<h3 id="registering">Creaci&#xF3;n del fichero y registro </h3>
<p>Lo primero que vamos a hacer en Glitch es crear un nuevo archivo cuyo nombre ser&#xE1; <code>public/service-worker.js</code>. En &#xE9;l escribiremos el c&#xF3;digo que controla la intercepci&#xF3;n de las peticiones.</p>
<p><img src="../imgs/new-file.png" alt="En Glitch, al especificar el nombre, especificamos tambi&#xE9;n la ruta"></p>
<p>Visita tu aplicaci&#xF3;n haciendo click en <code>Show Live</code>, abre las herramientas de desarrollo y haz clic sobre la pesta&#xF1;a <em>Application</em>.</p>
<p>En la lista de la izquierda, haz clic en el elemento <em>Service Workers</em> para comprobar que no hay ninguno asociado a ese origen.</p>
<p><img src="../imgs/application-tab.png" alt="La pesta&#xF1;a aplicaci&#xF3;n"></p>
<p>Recuerda que un origen no es lo mismo que un dominio. El origen es el protocolo junto con el nombre de dominio y el puerto. As&#xED;, <code>http://mozilla.org</code> y <code>https://mozilla.org</code> son or&#xED;genes distintos, como tambi&#xE9;n lo son <code>localhost:8000</code> y <code>localhost:3333</code>.</p>
<p>Un service worker debe registrarse desde el hilo principal. Edita <code>public/client.js</code> y a&#xF1;ade el siguiente c&#xF3;digo:</p>
<pre><code class="lang-js"><span class="hljs-keyword">if</span> (<span class="hljs-string">&apos;serviceWorker&apos;</span> <span class="hljs-keyword">in</span> navigator) {
  navigator.serviceWorker.register(<span class="hljs-string">&apos;/service-worker.js&apos;</span>)
  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&apos;&#xA1;Service Worker registrado!&apos;</span>); })
  .catch(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{ <span class="hljs-built_in">console</span>.error(<span class="hljs-string">&apos;Parece que hubo alg&#xFA;n problema:&apos;</span>, e)});
}
</code></pre>
<p>El condicional omite el proceso de registro si el navegador no soporta <em>service workers</em>. En caso de soportarlos, el m&#xE9;todo <a href="https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/register" target="_blank"><code>register</code></a> devuelve una promesa que, en caso de cumplirse, garantiza que el <em>service worker</em> pudo descargarse, interpretarse correctamente y se encuentra en proceso de instalaci&#xF3;n.</p>
<p>Por supuesto, has de incluir el script en el punto de entrada HTML. En este caso edita <code>views/index.html</code> y antes de la etiqueta de cierre de la cabecera <code>&lt;/head&gt;</code>, a&#xF1;ade la siguiente l&#xED;nea:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/client.js&quot;</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<p>Cuando tu aplicaci&#xF3;n se actualice, comprueba que en la consola aparece el mensaje de que todo ha ido bien y que en la secci&#xF3;n <em>Service workers</em> de la pesta&#xF1;a <em>Application</em> se muestra el <em>service worker</em> como aparece en la captura siguiente:</p>
<p><img src="../imgs/service-worker-registered.png" alt="Si todo ha ido bien, el status del service worker indica _activated and is running_"></p>
<p>Un <em>service worker</em> s&#xF3;lo puede registrarse desde un origen seguro, que utilice <a href="https://es.wikipedia.org/wiki/Hypertext_Transfer_Protocol_Secure" target="_blank">HTTPS</a>. Puedes comprobar otros requerimientos r&#xE1;pidamente en la infograf&#xED;a <a href="https://github.com/delapuente/service-workers-101#service-workers-101" target="_blank"><em>Service Workers 101</em></a>.</p>
<h3 id="installation">Instalaci&#xF3;n y activaci&#xF3;n del <em>service worker</em> </h3>
<p>Vamos a modificar el <em>service worker</em> &#x2014;de ahora en adelante <em>SW</em>&#x2014; m&#xFA;ltiples veces y cada vez que lo hagamos, Glitch relanzar&#xE1; nuestra aplicaci&#xF3;n. Es conveniente, por tanto, activar la opci&#xF3;n <em>Update on reload</em> del men&#xFA; <em>Service Workers</em> del panel <em>Application</em> para garantizar que el <em>SW</em> se actualiza en cada recarga.</p>
<p><img src="../imgs/update-on-reload-detail.png" alt="Detalle del interruptor para activar la recarga al refrescar"></p>
<p>El panel de aplicaci&#xF3;n deber&#xED;a indicar que nuestro <em>SW</em> funciona correctamente aunque todav&#xED;a no haga nada. Durante la instalaci&#xF3;n, el <em>SW</em> pasa por tres estados (que puedes revisar en la inforgraf&#xED;a <a href="https://github.com/delapuente/service-workers-101#service-workers-101" target="_blank"><em>Service Workers 101</em></a>):</p>
<ol>
<li>Instalando: pensado para preparar la infraestructura necesaria para el funcionamiento del <em>SW</em>.</li>
<li>Activando: pensado para retirar la infraestructura de alguna versi&#xF3;n anterior del <em>SW</em>.</li>
<li>Activo: listo para interceptar peticiones a la red.</li>
</ol>
<p>A&#xF1;ade el siguiente c&#xF3;digo al fichero del <em>service worker</em> <code>public/service-worker.js</code>:</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> VERSION = <span class="hljs-number">1</span>;
<span class="hljs-keyword">var</span> PREFIX = <span class="hljs-string">&apos;__pwa-workshop&apos;</span>;
<span class="hljs-keyword">var</span> CACHE_NAME = <span class="hljs-string">`<span class="hljs-subst">${PREFIX}</span>-assets-v<span class="hljs-subst">${VERSION}</span>`</span>;
<span class="hljs-keyword">var</span> ASSETS = [
  <span class="hljs-string">&apos;https://cdn.glitch.com/aa6a5f34-4aee-4eae-807f-ca86f623e58a%2Finvisible.svg?1500732711924&apos;</span>,
  <span class="hljs-string">&apos;https://cdn.glitch.com/aa6a5f34-4aee-4eae-807f-ca86f623e58a%2Ftick-sign.svg?1500732712044&apos;</span>,
  <span class="hljs-string">&apos;https://cdn.glitch.com/aa6a5f34-4aee-4eae-807f-ca86f623e58a%2Flike.svg?1500732712234&apos;</span>,
  <span class="hljs-string">&apos;https://cdn.glitch.com/aa6a5f34-4aee-4eae-807f-ca86f623e58a%2Flike-black.svg?1500733444163&apos;</span>,
  <span class="hljs-string">&apos;https://cdn.glitch.com/aa6a5f34-4aee-4eae-807f-ca86f623e58a%2Finvisible-black.svg?1500733601054&apos;</span>,
  <span class="hljs-string">&apos;https://cdn.glitch.com/aa6a5f34-4aee-4eae-807f-ca86f623e58a%2Ftick-sign-black.svg?1500733601379&apos;</span>,
  <span class="hljs-string">&apos;https://cdn.glitch.com/aa6a5f34-4aee-4eae-807f-ca86f623e58a%2Ficon196.png?1500664388904&apos;</span>,
  <span class="hljs-string">&apos;https://fonts.googleapis.com/css?family=Poppins&apos;</span>,
  <span class="hljs-string">&apos;https://fonts.gstatic.com/s/poppins/v2/HUuNgGR31mqIHE6zs0BlBgLUuEpTyoUstqEm5AMlJo4.woff2&apos;</span>,
  <span class="hljs-string">&apos;/client.js&apos;</span>,
  <span class="hljs-string">&apos;/style.css&apos;</span>,
  <span class="hljs-string">&apos;/error-page.html&apos;</span>,
  <span class="hljs-string">&apos;/&apos;</span>
];

self.addEventListener(<span class="hljs-string">&apos;install&apos;</span>, event =&gt; {
  event.waitUntil(<span class="hljs-built_in">Promise</span>.all([addAssets(), self.skipWaiting()]));
});

self.addEventListener(<span class="hljs-string">&apos;activate&apos;</span>, event =&gt; {
  event.waitUntil(<span class="hljs-built_in">Promise</span>.all([clearOldCaches(), self.clients.claim()]));
});
</code></pre>
<p>En el contexto de un <em>service worker</em> o de cualquier otro <em>worker</em>, <code>self</code> hace referencia siempre al objeto global. Con <code>addEventListener</code> podemos suscribirnos a los cambios en el ciclo de vida del <em>SW</em>.</p>
<p>El m&#xE9;todo <a href="https://developer.mozilla.org/en-US/docs/Web/API/ExtendableEvent/waitUntil" target="_blank"><code>waitUntil</code></a> de los eventos <code>install</code> y <code>activate</code> permite extender las fases de instalaci&#xF3;n y activaci&#xF3;n respectivamente, hasta que la promesa pasada como par&#xE1;metro se resuelva.</p>
<p>Entre la instalaci&#xF3;n y la activaci&#xF3;n, el navegador espera a que todos los clientes actualmente controlados por un <em>service worker</em> se cierren, antes de activar el siguiente. Con el m&#xE9;todo <a href="https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerGlobalScope/skipWaiting" target="_blank"><code>skipWaiting</code></a> podemos acelerar el proceso evitando la espera del <em>SW</em>.</p>
<p>Durante la activaci&#xF3;n, utilizamos el m&#xE9;todo <a href="https://developer.mozilla.org/en-US/docs/Web/API/Clients/claim" target="_blank"><code>claim</code></a> para hacer que el <em>SW</em> intercepte todas las peticiones originadas en los clientes activos (pesta&#xF1;as ya abiertas, otros <em>workers</em>&#x2026;) a partir de ahora.</p>
<p>Aun no hemos escrito las funciones <code>addAssets</code> y <code>clearOldCaches</code>, por lo que el proceso de instalaci&#xF3;n falla en tiempo de ejecuci&#xF3;n y la instalaci&#xF3;n se interrumpe. Pod&#xE9;is ver los errores relacionados con la instalaci&#xF3;n del <em>SW</em> bajo el estado, en la vista <em>Service Workers</em>, en la pesta&#xF1;a <em>Application</em>.</p>
<p><img src="../imgs/service-worker-errors-detail.png" alt="Detalle de los errores de instalaci&#xF3;n por la ausencia de las funciones"></p>
<p>Antes de continuar, <strong>borra los errores</strong> y luego a&#xF1;ade el siguiente listado con la implementaci&#xF3;n de las funciones que faltan:</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addAssets</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> self.caches.open(CACHE_NAME)
  .then(cache =&gt; cache.addAll(ASSETS));
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clearOldCaches</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> self.caches.keys()
  .then(allCaches =&gt; {
    <span class="hljs-keyword">return</span> allCaches.filter(cacheName =&gt; {
      <span class="hljs-keyword">var</span> isMine = cacheName.indexOf(PREFIX) === <span class="hljs-number">0</span>;
      <span class="hljs-keyword">var</span> isNotTheNewest = cacheName !== CACHE_NAME;
      <span class="hljs-keyword">return</span> isMine &amp;&amp; isNotTheNewest;
    });
  })
  .then(oldCaches =&gt; {
    <span class="hljs-keyword">return</span> oldCaches.map(cacheName =&gt; {
      <span class="hljs-keyword">return</span> self.caches.delete(cacheName);
    });
  })
  .then(deletingTasks =&gt; <span class="hljs-built_in">Promise</span>.all(deletingTasks));
}
</code></pre>
<p>Ls funci&#xF3;n <code>addAssets</code> acepta una lista de recursos (<em>assets</em>), y con el m&#xE9;todo <a href="https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage/open" target="_blank"><code>open</code></a>, abre una nueva cach&#xE9; (cre&#xE1;ndola si no exist&#xED;a) donde a&#xF1;adir estos recursos. Para ello utiliza el m&#xE9;todo <a href="https://developer.mozilla.org/en-US/docs/Web/API/Cache/addAll" target="_blank"><code>addAll</code></a> de la cach&#xE9;.</p>
<p>La lista de recursos <code>ASSETS</code> contiene los iconos de la aplicaci&#xF3;n, la hoja de estilos, el c&#xF3;digo JavaScript del cliente (exceptuando el <em>SW</em>), las fuentes, la p&#xE1;gina de error y el &#xED;ndice.</p>
<p>La funci&#xF3;n <code>clearOldCaches</code> obtiene todas los nombres de las caches en el origen con el m&#xE9;todo <a href="https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage/keys" target="_blank"><code>keys</code></a>, reconoce las propias y borra las antiguas con el m&#xE9;todo <a href="https://developer.mozilla.org/en-US/docs/Web/API/Cache/delete" target="_blank"><code>delete</code></a>.</p>
<p>Si todo ha ido bien, no deber&#xED;as ver nuevos errores bajo el estado del <em>service worker</em>. Si adem&#xE1;s haces click en el elemento <em>Cache storage</em>, deber&#xED;as poder ver un listado de las caches y su contenido (haz click en el icono de refrescar si no aparece nada). Prueba a cambiar el n&#xFA;mero de versi&#xF3;n para comprobar que el c&#xF3;digo funciona correctamente.</p>
<p><img src="../imgs/cache-contents.png" alt="Cache offline y su contenido"></p>
<h3 id="cache-strategies">Estrategias de cach&#xE9; </h3>
<p>Gracias a las cach&#xE9;s sin conexi&#xF3;n (<a href="https://developer.mozilla.org/en-US/docs/Web/API/Cache" target="_blank"><em>Offline Caches</em></a>) hemos guardado los recursos necesarios para recrear la interfaz de usuario sin necesidad de estar conectados a la red; pero aun no le hemos dicho al <em>SW</em> cu&#xE1;ndo debe servir estos recursos. Por el momento, todas las peticiones alcanzan la red.</p>
<p>Puedes ir al panel <em>Network</em> en las herramientas de desarrollador y activar el interruptor <em>Offline</em> para simular que no hay red. Realiza alguna acci&#xF3;n o recarga y ver&#xE1;s como la aplicaci&#xF3;n falla estrepitosamente.</p>
<p><img src="../imgs/offline-switch-detail.png" alt="Detalle del interruptor Offline que simula la ausencia de red"></p>
<p>Sin modificar una sola l&#xED;nea en el c&#xF3;digo de la <em>UI</em>, nuestra intenci&#xF3;n es crear una capa de red, en el <em>service worker</em>, que responda de forma diferente seg&#xFA;n el tipo de petici&#xF3;n y el estado de la conexi&#xF3;n.</p>
<p>Empieza a&#xF1;adiendo el siguiente listado, tras registrar el <em>listener</em> del evento <code>activate</code>:</p>
<pre><code class="lang-js">self.addEventListener(<span class="hljs-string">&apos;fetch&apos;</span>, event =&gt; {
  <span class="hljs-keyword">var</span> result = handleRequest(event.request);
  <span class="hljs-keyword">var</span> response = result[<span class="hljs-number">0</span>];
  <span class="hljs-keyword">var</span> completion = result[<span class="hljs-number">1</span>];
  event.respondWith(response);
  event.waitUntil(completion);
});
</code></pre>
<p>La funci&#xF3;n <code>handleRequest</code> ser&#xE1; la encargada de implementar esta capa de red y devolver&#xE1; una lista con dos promesas. El m&#xE9;todo <a href="https://developer.mozilla.org/en-US/docs/Web/API/FetchEvent/respondWith" target="_blank"><code>respondWith</code></a> consume la primera, que debe resolverse con un objeto del tipo <a href="https://developer.mozilla.org/en-US/docs/Web/API/Response" target="_blank"><code>Response</code></a> y ser&#xE1; entregado al navegador para que sirva de respuesta a la petici&#xF3;n. De nuevo, utilizaremos <a href="https://developer.mozilla.org/en-US/docs/Web/API/ExtendableEvent/waitUntil" target="_blank"><code>waitUntil</code></a> para extender la vida del <em>SW</em> hasta que la segunda promesa de la lista se resuelva.</p>
<p>Los <em>service workers</em> est&#xE1;n pensados para realizar una tarea concreta y cerrarse de forma que no consuman recursos innecesarios. Dada su naturaleza as&#xED;ncrona, no se puede determinar de antemano cu&#xE1;ndo un <em>service worker</em> ha terminado. Es por ello que utilizamos <code>waitUntil</code> con una promesa. Tal promesa expresa que <strong>todas las acciones que queremos realizar han terminado</strong>.</p>
<p>Por el mismo motivo, no se puede confiar en el estado global de un <em>service worker</em> <em>como mecanismo de persistencia</em> dado que, tarde o temprano, el navegador lo eliminar&#xE1; y el estado global se perder&#xE1;. Esto no significa que no podamos confiar en el estado global <em>para compartir valores comunes e inmutables</em> (como el listado de <code>ASSETTS</code>).</p>
<h4 id="estrategia-s&#xF3;lo-cach&#xE9;">Estrategia <em>s&#xF3;lo cach&#xE9;</em></h4>
<p>Antes de continuar, comprueba que has desactivado el modo <em>Offline</em> y refresca la pesta&#xF1;a.</p>
<p>Comencemos de forma sencilla. A&#xF1;ade el siguiente listado al final del fichero del <em>SW</em>:</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleRequest</span>(<span class="hljs-params">request</span>) </span>{
  <span class="hljs-keyword">if</span> (isAsset(request)) {
    <span class="hljs-keyword">return</span> only(fromCache(request));
  }
  <span class="hljs-keyword">return</span> only(fetch(request));
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isAsset</span>(<span class="hljs-params">request</span>) </span>{
  <span class="hljs-keyword">var</span> url = <span class="hljs-keyword">new</span> URL(request.url);
  <span class="hljs-keyword">return</span> !isIndex(request) &amp;&amp;
         (ASSETS.indexOf(url.href) &gt;= <span class="hljs-number">0</span> ||
         ASSETS.indexOf(url.pathname) &gt;= <span class="hljs-number">0</span>);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isIndex</span>(<span class="hljs-params">request</span>) </span>{
  <span class="hljs-keyword">var</span> url = <span class="hljs-keyword">new</span> URL(request.url);
  <span class="hljs-keyword">return</span> url.pathname === <span class="hljs-string">&apos;/&apos;</span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fromCache</span>(<span class="hljs-params">request</span>) </span>{
  <span class="hljs-keyword">return</span> self.caches.open(CACHE_NAME)
  .then(cache =&gt; cache.match(request));
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">only</span>(<span class="hljs-params">promise</span>) </span>{
  <span class="hljs-keyword">return</span> [promise, <span class="hljs-built_in">Promise</span>.resolve()];
}
</code></pre>
<p>Ve ahora a la pesta&#xF1;a <em>Network</em> y limpia los logs. Recarga la pesta&#xF1;a manualmente y observa los resultados en la lista de peticiones. Ver&#xE1;s como los recursos se sirven desde el <em>SW</em>:</p>
<p><img src="../imgs/network-requests-from-service-worker.png" alt="En la columna size se lee &quot;from service worker&quot; indicando que el recurso se ha servidor desde un service worker"></p>
<p>Date cuenta de que aunque se indique que el recurso se ha servido desde el <em>SW</em>, esto <strong>no significa que se haya servido desde una cach&#xE9;</strong>.</p>
<p>Si activas el modo <em>Offline</em> y recargas, ver&#xE1;s c&#xF3;mo la aplicaci&#xF3;n sigue fallando. Esto es porque el &#xED;ndice no se considera un recurso (<em>asset</em>) en la funci&#xF3;n <code>isAsset</code> y, por tanto, no se sirve desde la cach&#xE9;.</p>
<p>Sin embargo, podr&#xED;as consultar la p&#xE1;gina de error <code>/error-page.html</code> dado que esta s&#xED; se considera un recurso y se servir&#xE1; desde la cach&#xE9;. Lo mismo ocurre con cualquier recurso que incluyeras en la variable <code>ASSETS</code>.</p>
<p>El c&#xF3;digo anterior se explica por s&#xED; mismo: si la petici&#xF3;n es un recurso, lo servimos desde la cach&#xE9; con la funci&#xF3;n <code>fromCache</code>. Si no, lo servimos desde la red con <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch" target="_blank"><code>fetch</code></a>. La nueva <a href="https://developer.mozilla.org/en/docs/Web/API/Fetch_API" target="_blank"><em>API fetch</em></a> tiende a reemplazar a la famosa interfaz <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest" target="_blank"><code>XMLHttpRequest</code></a> y adem&#xE1;s, es la &#xFA;nica forma de realizar una petici&#xF3;n desde un <em>SW</em>. Ninguna de las peticiones originadas en un <em>SW</em> ser&#xE1; jam&#xE1;s interceptada.</p>
<p>La funci&#xF3;n <code>fromCache</code> usa el m&#xE9;todo <a href="https://developer.mozilla.org/en-US/docs/Web/API/Cache/match" target="_blank"><code>match</code></a> de las cach&#xE9;s para buscar una respuesta a la petici&#xF3;n pasada como par&#xE1;metro.</p>
<p>La funci&#xF3;n <code>only</code> es una funci&#xF3;n auxiliar que produce una lista cuyo segundo elemento es una promesa resuelta. Se espera que se use dentro de la funci&#xF3;n <code>handleRequest</code> para indicar que no se necesita esperar por nada al atender el evento <code>fetch</code>.</p>
<p>Desactiva el modo <em>Offline</em> y vuelve al &#xED;ndice (<code>/</code>) antes de continuar.</p>
<h4 id="estrategia-red-m&#xE1;s-actualizaci&#xF3;n-o-alternativa-sin-conexi&#xF3;n">Estrategia <em>red m&#xE1;s actualizaci&#xF3;n o alternativa sin conexi&#xF3;n</em></h4>
<p>Veamos ahora c&#xF3;mo tratar las acciones. Modifica la funci&#xF3;n <code>handleRequest</code> para que quede de la siguiente forma:</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleRequest</span>(<span class="hljs-params">request</span>) </span>{
  <span class="hljs-keyword">if</span> (isAsset(request)) {
    <span class="hljs-keyword">return</span> only(fromCache(request));
  }
  <span class="hljs-keyword">if</span> (isIndex(request) || isAction(request)) {
    <span class="hljs-keyword">var</span> offlinePage = isIndex(request) ? cachedIndex() : errorPage();
    <span class="hljs-keyword">return</span> fetchAndUpdateIndex(request, offlinePage);  
  }
  <span class="hljs-keyword">return</span> only(fetch(request));
}
</code></pre>
<p>En palabras:</p>
<ol>
<li>Si la petici&#xF3;n es un recurso, sabemos que est&#xE1; en cach&#xE9; luego lo servimos desde la cach&#xE9;.</li>
<li>Si la petici&#xF3;n es el &#xED;ndice o una operaci&#xF3;n sobre la <em>API</em>, queremos que llegue a la red. De no haber red, queremos poder dar una alternativa sin conexi&#xF3;n. Esta alternativa depender&#xE1; de si estamos visitando el &#xED;ndice o realizando una operaci&#xF3;n sobre la <em>API</em>. En el primer caso devolveremos la lista m&#xE1;s actualizada desde la cach&#xE9;. En el segundo mostraremos una pantalla de error, dando la opci&#xF3;n de volver al &#xED;ndice.</li>
<li>En cualquier otro caso, dejaremos que la petici&#xF3;n alcance la red normalmente.</li>
</ol>
<p>A&#xF1;ade el siguiente listado al final del archivo:</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isAction</span>(<span class="hljs-params">request</span>) </span>{
  <span class="hljs-keyword">var</span> url = <span class="hljs-keyword">new</span> URL(request.url);
  <span class="hljs-keyword">return</span> url.pathname.indexOf(<span class="hljs-string">&apos;/recommendations&apos;</span>) === <span class="hljs-number">0</span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cachedIndex</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> fromCache(<span class="hljs-string">&apos;/&apos;</span>);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">errorPage</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> fromCache(<span class="hljs-string">&apos;/error-page.html&apos;</span>);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fetchAndUpdateIndex</span>(<span class="hljs-params">request, offlineAlternative</span>) </span>{
  <span class="hljs-keyword">var</span> done;
  <span class="hljs-keyword">var</span> completion = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(resolve =&gt; done = resolve);
  <span class="hljs-keyword">var</span> response = doRequest(request, offlineAlternative, done);
  <span class="hljs-keyword">return</span> [response, completion];

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doRequest</span>(<span class="hljs-params">request, offlineAlternative, done</span>) </span>{
    <span class="hljs-keyword">return</span> fetch(request)
    .then(response =&gt; {
      <span class="hljs-keyword">if</span> (!response.ok) {
        done();
        <span class="hljs-keyword">return</span> offlineAlternative;
      }
      updateIndex(response.clone()).then(done);
      <span class="hljs-keyword">return</span> response;
    })
    .catch(reason =&gt; {
      done();
      <span class="hljs-keyword">return</span> offlineAlternative;
    });
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateIndex</span>(<span class="hljs-params">response</span>) </span>{
  <span class="hljs-keyword">return</span> self.caches.open(CACHE_NAME)
  .then(cache =&gt; cache.put(<span class="hljs-string">&apos;/&apos;</span>, response));
}
</code></pre>
<p>La funci&#xF3;n <code>fetchAndUpdateIndex</code>, en particular <code>doRequest</code>, implementa toda la l&#xF3;gica de cach&#xE9;. Respondemos con la alternativa sin conexi&#xF3;n cuando <code>fetch</code> falla o el servidor devuelve una respuesta <em>no OK</em>, lo que quiere decir que no est&#xE1; en el rango <a href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#2xx_Success" target="_blank"><code>2XX</code></a>. Si todo ha salido bien, <code>updateIndex</code> actualiza el &#xED;ndice (la lista de recomendaciones) con una copia de la petici&#xF3;n, utilizando el m&#xE9;todo <a href="https://developer.mozilla.org/en-US/docs/Web/API/Cache/put" target="_blank"><code>put</code></a>) de las cach&#xE9;s. La respuesta original se usa para responder al cliente.</p>
<p>El cuerpo de una respuesta <strong>s&#xF3;lo puede utilizarse una vez</strong>, o se utiliza para representarse en el cliente o se utiliza para guardarse en la cach&#xE9;. Es por ello que copiamos la respuesta con <a href="https://developer.mozilla.org/en-US/docs/Web/API/Response/clone" target="_blank"><code>clone</code></a> antes de actualizar la cach&#xE9;.</p>
<p>Con estos cambios ya puedes pasar a modo <em>Offline</em> y probar a visitar el &#xED;ndice y a realizar alguna operaci&#xF3;n para alcanzar la p&#xE1;gina informativa.</p>
<h3 id="service-workers-conclusion">Conclusi&#xF3;n </h3>
<p>Antes de terminar la lecci&#xF3;n, comprueba:</p>
<ul>
<li>Que habiendo activado el interruptor <em>Offline</em>, puedes seguir accediendo al &#xED;ndice.</li>
<li>Que realizar cualquier acci&#xF3;n se traduce en la pantalla de error.</li>
<li>Que puedes volver al &#xED;ndice desde la pantalla de error.</li>
<li>Que no falta ninguna imagen.</li>
<li>Si te sientes valiente, desconecta internet, cierra el navegador y prueba a entrar otra vez en el &#xED;ndice.</li>
</ul>
<p>Los <em>service workers</em> son una potent&#xED;sima herramienta que permite la implementaci&#xF3;n de multitud de casos de uso. Su principal cometido es el de facilitar la <a href="https://jakearchibald.com/2014/offline-cookbook/" target="_blank">implementaci&#xF3;n de distintas estrategias de cach&#xE9;</a> pero, por su naturaleza como proxy de red, tambi&#xE9;n habilita <a href="https://hacks.mozilla.org/2015/12/beyond-offline/" target="_blank">otros usos m&#xE1;s all&#xE1; de los convencionales</a>.</p>
<p>Si quieres explorar estos y otros usos de los <em>service workers</em>, te recomiendo que visites el <a href="https://serviceworke.rs" target="_blank">Service Worker Cookbook</a>.</p>
<h2 id="web-manifest">2. El manifiesto web </h2>
<p>El manifiesto web es un fichero <em>JSON</em> que contiene un objeto con <a href="https://w3c.github.io/manifest/#manifest-and-its-members" target="_blank">claves bien conocidas</a>, y que se enlaza desde nuestra p&#xE1;gina web de manera que el navegador obtenga la informaci&#xF3;n al cargar la cabecera de la p&#xE1;gina.</p>
<p>La informaci&#xF3;n del manifiesto puede utilizarse para mejorar la integraci&#xF3;n del sitio web con el navegador o con el sistema operativo, aunque tambi&#xE9;n puede ser utilizado por los buscadores web para mejorar la clasificaci&#xF3;n de estas p&#xE1;ginas web.</p>
<p>Crea un nuevo fichero en Glitch llamado <code>public/manifest.json</code> y a&#xF1;ade el siguiente contenido:</p>
<pre><code class="lang-js">{
  <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Recommendations&quot;</span>,
  <span class="hljs-string">&quot;short_name&quot;</span>: <span class="hljs-string">&quot;Recommendations&quot;</span>,
  <span class="hljs-string">&quot;description&quot;</span>: <span class="hljs-string">&quot;Keep track of everything you&apos;re recommended&quot;</span>,
  <span class="hljs-string">&quot;theme_color&quot;</span>: <span class="hljs-string">&quot;#FFDD60&quot;</span>,
  <span class="hljs-string">&quot;background_color&quot;</span>: <span class="hljs-string">&quot;#FFDD60&quot;</span>,
  <span class="hljs-string">&quot;display&quot;</span>: <span class="hljs-string">&quot;standalone&quot;</span>,
  <span class="hljs-string">&quot;icons&quot;</span>: [
    {
      <span class="hljs-string">&quot;src&quot;</span>: <span class="hljs-string">&quot;https://cdn.glitch.com/aa6a5f34-4aee-4eae-807f-ca86f623e58a%2Ficon196.png?1500664388904&quot;</span>,
      <span class="hljs-string">&quot;sizes&quot;</span>: <span class="hljs-string">&quot;196x196&quot;</span>,
      <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;image/png&quot;</span>
    }
  ]
}
</code></pre>
<p>Antes de profundizar en cada clave, enlaza el manifiesto con tu p&#xE1;gina web a&#xF1;adiendo el siguiente elemento HTML antes del cierre de la etiqueta <code>head</code>:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;manifest&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/manifest.json&quot;</span>&gt;</span>
</code></pre>
<p>Las claves <code>name</code>, <code>short_name</code> y <code>description</code> son autoexplicativas. La clave <code>short_name</code> se prefiere cuando el espacio en pantalla para mostrar el nombre es limitado. Por ejemplo, en el caso del nombre bajo el icono en la pantalla de inicio.</p>
<p>Los campos <code>theme_color</code> y <code>background_color</code> colorean la interfaz de usuario del navegador. En particular, <code>background_color</code> se refiere al color de fondo del navegador mientras se carga la p&#xE1;gina web.</p>
<p>El campo <code>display</code> permite seleccionar una experiencia de navegaci&#xF3;n &#xF3;ptima, siendo <code>standalone</code> el valor que corresponde a la ausencia total de elementos de navegaci&#xF3;n.</p>
<p>La lista <code>icons</code> contiene una lista de iconos con entradas para las distintas resoluciones de pantalla y densidades de p&#xED;xeles.</p>
<p>Para una descripci&#xF3;n completa y con ejemplos de los campos del manifiesto, puedes consultar <a href="https://developer.mozilla.org/en-US/docs/Web/Manifest#Members" target="_blank">la p&#xE1;gina sobre el manifiesto web de la MDN</a>.</p>
<p>Las herramientas de desarrollador de Chrome incluyen, en la pesta&#xF1;a <em>Application</em> y secci&#xF3;n <em>Manifest</em>, una visualizaci&#xF3;n de los distintos campos del mismo.</p>
<h3 id="web-manifest-conclusion">Conclusi&#xF3;n </h3>
<p>Visita tu aplicaci&#xF3;n desde el m&#xF3;vil usando Opera, Chrome o Samsung Internet, navegadores que ponen especial &#xE9;nfasis en la integraci&#xF3;n con el manifiesto y a&#xF1;ade tu aplicaci&#xF3;n a la pantalla de inicio:</p>
<p><img src="../imgs/android-integration.gif" alt="Integraci&#xF3;n con Android que ofrece Chrome"></p>
<ul>
<li>Observa la <em>splashpage</em> que genera Chrome gracias al color de fondo y la lista de iconos.</li>
<li>F&#xED;jate en la ausencia de interfaz de usuario relacionada con el navegador.</li>
<li>Y observa como la aplicaci&#xF3;n tiene su propio lugar en el cambiador de tareas.</li>
</ul>
<p>Con estas modificaciones, tu sitio web ya entra en las definiciones de <em>progressive web apps</em> m&#xE1;s extendidas. No obstante recuerda que las <a href="https://medium.com/samsung-internet-dev/progressive-web-apps-are-a-toolkit-not-a-recipe-b2fd68613de5" target="_blank"><em>PWA</em> no son una receta sino una herramienta</a>.</p>
<h2 id="push-notifications">3. Uso b&#xE1;sico de notificaciones <em>push</em> </h2>
<p>Las notificaciones <em>push</em> tienen una interpretaci&#xF3;n doble: desde el punto de vista de red, una notificaci&#xF3;n <em>push</em> es una comunicaci&#xF3;n desde el servidor al cliente, iniciada por el servidor sin que el cliente haya realizado una petici&#xF3;n previa.</p>
<p>Por otro lado, desde el punto de vista de la experiencia de usuario, una notificaci&#xF3;n <em>push</em> es un elemento de interfaz cuya finalidad es interrumpir levemente la actividad del usuario para comunicar cierta informaci&#xF3;n.</p>
<p>Lo com&#xFA;n es encontrar una tercera definici&#xF3;n que re&#xFA;ne estas dos y establece que cualquier comunicaci&#xF3;n iniciada en el servidor debe manifestarse ante el usuario. De hecho, los navegadores actuales fuerzan esta dependencia de forma que si no se muestra una notificaci&#xF3;n al usuario como respuesta a una notificaci&#xF3;n <em>push</em> proveniente del servidor, el navegador muestra una gen&#xE9;rica.</p>
<p>No obstante, algunos navegadores est&#xE1;n experimentando con permitir algunas notificaciones silenciosas, que no interrumpan la acci&#xF3;n del usuario.</p>
<p>De todas formas, conviene conocer la diferencia entre el protocolo de red y la met&#xE1;fora visual.</p>
<h3 id="client-server">Estableciendo la comunicaci&#xF3;n cliente-servidor </h3>
<p><strong>Nota</strong>: configurar las notificaciones <em>push</em> para que funcionen con Chrome, Samsung Internet y Opera requiere conocer los valores <code>gcm_sender_id</code> y <code>gcm_api_key</code> de una aplicaci&#xF3;n <a href="https://firebase.google.com/" target="_blank">Firebase</a>. Aunque se te propocionar&#xE1;n unos valores de prueba durante el taller, puedes crear tu propia aplicaci&#xF3;n Firebase y consultar esta <a href="http://dev.tapjoy.com/faq/how-to-find-sender-id-and-api-key-for-gcm/" target="_blank">gu&#xED;a de TapJoy para saber d&#xF3;nde encontrarlos</a>.</p>
<hr>
<p><strong>Nota</strong>: vamos a modificar el el c&#xF3;digo del fichero <code>public/client.js</code>. Este fichero es un recurso y, por tanto, se encuentra cacheado. Para que el c&#xF3;digo se actualice, tenemos que hacer que el <em>service worker</em> realice una nueva descarga del recurso durante la instalaci&#xF3;n. Antes de editarlo, aseg&#xFA;rate de tener el interruptor <em>Update on reload</em> (en la secci&#xF3;n <em>Service Workers</em> de la pesta&#xF1;a <em>Application</em>) activado.</p>
<p>Tambi&#xE9;n puedes borrar todos los datos asociados a la aplicaci&#xF3;n, en la secci&#xF3;n <em>Clear storate</em> de la pesta&#xF1;a <em>Application</em>.</p>
<p><img src="../imgs/clear-storage.png" alt="Dejando todo marcado y haciendo clic en clear storage, reseteamos el estado de la aplicaci&#xF3;n, borrando cach&#xE9;s y service workers"></p>
<hr>
<p>Comenzar a enviar notificaciones, sin el permiso expl&#xED;cito del usuario, podr&#xED;a llegar a ser molesto para el usuario. Por ello, los navegadores prefieren que el usuario otorgue permiso expl&#xED;cito para recibir notificaciones. En el c&#xF3;digo de cliente, esto se traduce a pedir una subscripci&#xF3;n.</p>
<p>Edita el fichero <code>public/manifest.json</code> y a&#xF1;ade la clave <code>gcm_sender_id</code> con el valor que te proporcionar&#xE1;n en el taller o el que obtengas de tu aplicaci&#xF3;n Firebase.</p>
<p>Ahora abre el fichero <code>public/client.js</code> y modif&#xED;calo para que quede as&#xED;:</p>
<pre><code class="lang-js"><span class="hljs-keyword">if</span> (<span class="hljs-string">&apos;serviceWorker&apos;</span> <span class="hljs-keyword">in</span> navigator) {
  navigator.serviceWorker.register(<span class="hljs-string">&apos;/service-worker.js&apos;</span>)
  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">registration</span>) </span>{ <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&apos;&#xA1;Service Worker registrado!&apos;</span>); })
  .catch(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{ <span class="hljs-built_in">console</span>.error(<span class="hljs-string">&apos;Parece que hubo alg&#xFA;n problema:&apos;</span>, e)});

  navigator.serviceWorker.ready.then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">registration</span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-string">&apos;pushManager&apos;</span> <span class="hljs-keyword">in</span> registration) {
      <span class="hljs-keyword">return</span> subscribeToNotifications(registration.pushManager);
    }
  });
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">subscribeToNotifications</span>(<span class="hljs-params">pushManager</span>) </span>{
  <span class="hljs-keyword">return</span> pushManager.getSubscription()
  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">subscription</span>) </span>{
    <span class="hljs-keyword">if</span> (subscription) {
      <span class="hljs-keyword">return</span> subscription;
    }
    <span class="hljs-keyword">return</span> pushManager.subscribe({ userVisibleOnly: <span class="hljs-literal">true</span> });
  })
  .then(sendDetailsToTheServer);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sendDetailsToTheServer</span>(<span class="hljs-params">subscription</span>) </span>{
  <span class="hljs-keyword">return</span> fetch(<span class="hljs-string">&apos;/subscribe&apos;</span>, {
    method: <span class="hljs-string">&apos;POST&apos;</span>,
    headers: {
      <span class="hljs-string">&apos;Content-Type&apos;</span>: <span class="hljs-string">&apos;application/json&apos;</span>
    },
    body: <span class="hljs-built_in">JSON</span>.stringify({
      endpoint: subscription.endpoint,
      key: toBase64(subscription.getKey(<span class="hljs-string">&apos;p256dh&apos;</span>)),
      auth: toBase64(subscription.getKey(<span class="hljs-string">&apos;auth&apos;</span>))
    })
  });
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toBase64</span>(<span class="hljs-params">target</span>) </span>{
  <span class="hljs-keyword">return</span> !target ? <span class="hljs-string">&apos;&apos;</span> :
         btoa(<span class="hljs-built_in">String</span>.fromCharCode.apply(<span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(target)));
}
</code></pre>
<p>Lo que estamos haciendo con este listado es pedir al <strong>servicio de notificaciones del navegador</strong> que nos proporcione una subscripci&#xF3;n. Es decir, un canal seguro por el que transmitir informaci&#xF3;n hacia el cliente.</p>
<p>Primero comprobamos que no exista una subscripci&#xF3;n anterior con el m&#xE9;todo <a href="https://developer.mozilla.org/en-US/docs/Web/API/PushManager/getSubscription" target="_blank"><code>getSubscription</code></a> de la interfaz <a href="https://developer.mozilla.org/en-US/docs/Web/API/PushManager" target="_blank"><code>PushManager</code></a>. si existe, reciclaremos esta pero si no, pediremos una subscripci&#xF3;n con el m&#xE9;todo <a href="https://developer.mozilla.org/en-US/docs/Web/API/PushManager/subscribe" target="_blank"><code>subscribe</code></a>.</p>
<p>El par&#xE1;metro <code>userVisibleOnly</code> garantiza al navegador que siempre mostraremos una notificaci&#xF3;n al usuario. Esta es una restricci&#xF3;n impuesta por el navegador Chrome.</p>
<p>En el momento que llamamos a <code>subscribe</code>, el navegador comprueba los permisos otorgados por el usuario y pregunta en caso de que no exista el permiso para ese dominio.</p>
<p><img src="../imgs/push-permission.png" alt="Di&#xE1;logo de petici&#xF3;n del permiso"></p>
<p>Si el usuario deniega el permiso, no podremos volver a mostrar el di&#xE1;logo. Por esto, conviene planificar el momento en el que pedimos el permiso y presentar la caracter&#xED;stica al usuario haciendo, por ejemplo, que la llamada a <code>subscribe</code> se produzca como consecuencia de una acci&#xF3;n del usuario. Siempre ser&#xE1; mejor preguntarle dos veces que perder la oportunidad de preguntarle para siempre.</p>
<p>Si trabaj&#xE1;ramos en un sitio web real, quiz&#xE1; debi&#xE9;ramos pedir permiso cuando sepamos algo m&#xE1;s sobre el usuario: cuando detectemos que no ha marcado ninguna recomendaci&#xF3;n durante semanas o, si se tratara de un blog, al detectar que el usuario termina de leer un art&#xED;culo, o al finalizar una compra con &#xE9;xito, si se tratase de un sitio de comercio <em>online</em>.</p>
<p>La subscripci&#xF3;n incluye una <em>URL</em> o <em>endpoint</em> al que realizaremos las peticiones de env&#xED;o de las notificaciones y unas claves necesarias para cifrar el contenido de las mismas.</p>
<p>F&#xED;jate en que la interfaz JavaScript que devuelve la subscripci&#xF3;n s&#xF3;lo se comunica con el navegador y es necesario que el cliente comunique a su servidor los detalles de la subscripci&#xF3;n, que es lo que se hace en la funci&#xF3;n <code>sendDetailsToTheServer</code>. Para ello utilizamos la funci&#xF3;n  <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch" target="_blank"><code>fetch</code></a> de la que ya hab&#xED;amos hablado anteriormente.</p>
<p>Pese a que aceptemos el permiso, la subscripci&#xF3;n no funcionar&#xE1;. Si consultas la consola ver&#xE1;s que el servidor responde con un error <code>404</code> puesto que la <em>API</em> para realizar la subscripci&#xF3;n a&#xFA;n no existe y no podemos comunicar los detalles de la subscripci&#xF3;n a nuestro servidor:</p>
<p><img src="../imgs/error-404.png" alt="La consola muestra un error 404"></p>
<p>Edita ahora el fichero del servidor <code>server.js</code> para que guarde los detalles de la subscripci&#xF3;n. A&#xF1;ade la siguiente ruta justo antes de la declaraci&#xF3;n de <code>recommendations</code>:</p>
<pre><code class="lang-js">app.post(<span class="hljs-string">&apos;/subscribe&apos;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">request, response</span>) </span>{
  subscriptions[request.body.endpoint] = {
    key: request.body.key,
    auth: request.body.auth
  };
  response.sendStatus(<span class="hljs-number">201</span>);
});

<span class="hljs-keyword">var</span> subscriptions = {};
</code></pre>
<p>En la pesta&#xF1;a <em>Network</em>, puedes comprobar el resultado de la petici&#xF3;n <code>POST</code> al servidor:</p>
<p><img src="../imgs/subscription-success.png" alt="Detalle de la petici&#xF3;n post que incluye el endpoint y las claves de cifrado"></p>
<h3 id="sending-notifications">Enviando notificaciones a los clientes </h3>
<p>&#xBF;Recuerdas la definici&#xF3;n de notificaci&#xF3;n <em>push</em>? En este punto vamos a implementar la primera interpretaci&#xF3;n. Es decir, la comunicaci&#xF3;n que ocurre desde el servidor hacia el cliente.</p>
<p>Para ello modifica el c&#xF3;digo del archivo <code>server.js</code> para que haga uso de la biblioteca <code>WebPush</code> que abstrae los detalles acerca de c&#xF3;mo enviar notificaciones a trav&#xE9;s de una interfaz m&#xE1;s amable. Comienza solicitando la biblioteca a&#xF1;adiendo la siguiente l&#xED;nea al comienzo del archivo:</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> webPush = <span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;web-push&apos;</span>);
webPush.setGCMAPIKey(<span class="hljs-string">&apos;XXXXXXXXX&apos;</span>); <span class="hljs-comment">// Reemplaza esta valor por el que te</span>
                                   <span class="hljs-comment">// proporcionen en el taller o por el que</span>
                                   <span class="hljs-comment">// obtengas de tu aplicaci&#xF3;n Firebase.</span>
</code></pre>
<p>Ahora modifica la declaraci&#xF3;n de <code>listener</code> para llamar al planificador de notificaciones:</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> listener = app.listen(process.env.PORT, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&apos;Your app is listening on port &apos;</span> + listener.address().port);
  scheduleNotification();
});

<span class="hljs-keyword">var</span> NOTIFICATION_PERIOD = <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>; <span class="hljs-comment">// 1 min</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">scheduleNotification</span>(<span class="hljs-params"></span>) </span>{
  setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">const</span> total = getUncheckedRecommendations();
    <span class="hljs-keyword">if</span> (total &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">const</span> summary = getSummary(total);
      <span class="hljs-built_in">Object</span>.keys(subscriptions).forEach(sendNotification.bind(<span class="hljs-literal">undefined</span>, summary));
    }
    scheduleNotification();
  }, NOTIFICATION_PERIOD);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getUncheckedRecommendations</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> recommendations.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">total, recommendation</span>) </span>{
    <span class="hljs-keyword">return</span> recommendation.unchecked ? total + <span class="hljs-number">1</span> : total;
  }, <span class="hljs-number">0</span>);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSummary</span>(<span class="hljs-params">total</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-string">`You still have <span class="hljs-subst">${total}</span> unchecked recommendation<span class="hljs-subst">${total &gt; 1 ? &apos;s&apos; : &apos;&apos;}</span>`</span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sendNotification</span>(<span class="hljs-params">summary, endpoint</span>) </span>{
  <span class="hljs-keyword">const</span> subscription = {
    endpoint,
    keys: {
      auth: subscriptions[endpoint].auth,
      p256dh: subscriptions[endpoint].key
    },
    ttl: <span class="hljs-number">60</span> * <span class="hljs-number">60</span>
  };
  webPush.sendNotification(subscription, summary);
}
</code></pre>
<p>Las funciones <code>getUncheckedRecommendations</code> y <code>getSummary</code> no tienen misterio. La primera cuenta el n&#xFA;mero de recomendaciones que aun no hemos comprobado y la segunda compone un mensaje con este n&#xFA;mero.</p>
<p>La funci&#xF3;n <code>sendNotification</code> utiliza la biblioteca <code>webPush</code> para enviar una notificaci&#xF3;n mediante el m&#xE9;todo <a href="https://github.com/web-push-libs/web-push#sendnotificationpushsubscription-payload-options" target="_blank"><code>sendNotification</code></a>.</p>
<p>La constante <code>NOTIFICATION_PERIOD</code> establece cada cu&#xE1;nto se lanzar&#xE1; una nueva notificaci&#xF3;n. Cuando hayamos comprobado que todo funciona podemos elevar este n&#xFA;mero a 48 horas o el tiempo que consideremos oportuno.</p>
<p>Recuerda que, cuando modificas el servidor, Glitch relanza la aplicaci&#xF3;n y todas las subscripciones se pierden. Es necesario <strong>recargar el cliente para que este env&#xED;e una nueva subscripci&#xF3;n al servidor</strong>.</p>
<h3 id="showing-notifications">Mostrando la notificaci&#xF3;n al usuario </h3>
<p>Es dif&#xED;cil comprobar que, efectivamente, la notificaci&#xF3;n ha alcanzado al cliente porque este no la trata: no hay a&#xFA;n una asociaci&#xF3;n entre recibir una notificaci&#xF3;n desde el servidor y usar la interfaz de usuario para mostrarla.</p>
<p>Esto lo arreglaremos en el <em>service worker</em>. Lo que haremos ser&#xE1; a&#xF1;adir un manejador para el evento <a href="https://developer.mozilla.org/en-US/docs/Web/Events/push" target="_blank"><code>push</code></a>. Modifica el fichero del <em>SW</em> <code>public/service-worker.js</code> y a&#xF1;ade esto al final del mismo:</p>
<pre><code class="lang-js">self.addEventListener(<span class="hljs-string">&apos;push&apos;</span>, event =&gt; {
  <span class="hljs-keyword">var</span> payload = event.data.text();
  event.waitUntil(self.registration.showNotification(<span class="hljs-string">&apos;Recommendations&apos;</span>, {
    body: payload
  }));
});
</code></pre>
<p>El m&#xE9;todo <a href="https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerRegistration/showNotification" target="_blank"><code>showNotification</code></a> mostrar&#xE1; la interfaz de usuario del sistema operativo asociada a una notificaci&#xF3;n. Como cuerpo de la notificaci&#xF3;n, utilizaremos el contenido de la notificaci&#xF3;n <em>push</em> que est&#xE1; disponible a trav&#xE9;s de la propiedad <a href="https://developer.mozilla.org/en-US/docs/Web/API/PushMessageData" target="_blank"><code>data</code></a> del evento.</p>
<p>Recuerda recargar el cliente para que env&#xED;e la informaci&#xF3;n de su suscripci&#xF3;n. Al cabo de 1 minuto deber&#xED;as poder ver la notificaci&#xF3;n:</p>
<p><img src="../imgs/notification-detail.png" alt="Detalle de la notificaci&#xF3;n"></p>
<h3 id="notification-action">Acci&#xF3;n al pulsar en la notificaci&#xF3;n </h3>
<p>Las notificaciones pueden recibirse sin tener la pesta&#xF1;a abierta e incluso, sin tener el navegador abierto. Por ello, al hacer click sobre la notificaci&#xF3;n ser&#xED;a conveniente recuperar la pesta&#xF1;a con la aplicaci&#xF3;n o, en su defecto, abrir una pesta&#xF1;a nueva.</p>
<p>El evento <a href="https://developer.mozilla.org/en-US/docs/Web/Events/notificationclick" target="_blank"><code>notificationclick</code></a> nos permite responder a la pulsaci&#xF3;n sobre una notificaci&#xF3;n. A&#xF1;ade el siguiente listado al final del <em>SW</em>:</p>
<pre><code class="lang-js">self.addEventListener(<span class="hljs-string">&apos;notificationclick&apos;</span>, event =&gt; {
  event.waitUntil(focusOnOpenTabOrNew());
});

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">focusOnOpenTabOrNew</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> self.clients.matchAll({ type: <span class="hljs-string">&apos;window&apos;</span> })
  .then(clientList =&gt; {
    <span class="hljs-keyword">if</span> (clientList.length &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span> clientList[<span class="hljs-number">0</span>].focus();
    }
    <span class="hljs-keyword">return</span> self.clients.openWindow(<span class="hljs-string">&apos;/&apos;</span>);
  });
}
</code></pre>
<p>Como en otras ocasiones, utilizamos <code>waitUntil</code> para mantener el <em>SW</em> corriendo hasta que todas las operaciones as&#xED;ncronas hayan terminado. Esta vez, utilizamos el m&#xE9;todo <a href="https://developer.mozilla.org/en-US/docs/Web/API/Clients/matchAll" target="_blank"><code>matchAll</code></a> para recuperar un listado completo de todas las ventanas/pesta&#xF1;as controladas por el <em>SW</em> (de ah&#xED; el par&#xE1;metro <code>type</code>). Si no hay ninguna, abriremos una utilizando <a href="https://developer.mozilla.org/en-US/docs/Web/API/Clients/openWindow" target="_blank"><code>openWindow</code></a>. Si existe alguna, bastar&#xE1; con darle el foco de atenci&#xF3;n mediante su m&#xE9;todo <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/focus" target="_blank"><code>focus</code></a>.</p>
<h3 id="push-notifications-conclusion">Conclusi&#xF3;n </h3>
<p>Has llegado al final del taller de aplicaciones progresivas. Antes de finalizar, comprueba:</p>
<ol>
<li>Que recibes las notificaciones peri&#xF3;dicamente.</li>
<li>Que si marcas como vistas todas tus recomendaciones, no recibes notificaci&#xF3;n.</li>
<li>Que recibes las notificaciones desde el m&#xF3;vil (incluso cuando el navegador no est&#xE1; abierto).</li>
<li>Que si cierras todas las pesta&#xF1;as, se abre una nueva al pulsar sobre la notificaci&#xF3;n.</li>
<li>Que si ya hay una pesta&#xF1;a abierta, esta recupera el foco tras pulsar sobre la notificaci&#xF3;n.</li>
</ol>
<p>Recuerda que puedes encontrar otras formas de utilizar las notificaciones <em>push</em> en la <a href="https://serviceworke.rs/web-push.html" target="_blank">secci&#xF3;n de notificaciones <em>push</em> del Service Worker Cookbook</a>. Las notificaciones <em>push</em> pueden convertirse en una herramienta de captaci&#xF3;n y conversi&#xF3;n de clientes extraordinaria, pero tambi&#xE9;n pueden llegar a resultar frustrantes para el usuario. Por ello, piensa:</p>
<ol>
<li>Cu&#xE1;ndo pedir permiso. Recuerda que s&#xF3;lo tienes una oportunidad de que el usuario te otorgue el permiso para notificar. Echa un vistazo a algunos <a href="(https:/developers.google.com/web/fundamentals/engage-and-retain/push-notifications/permission-ux">patrones de experiencia de usuario para pedir permiso</a>).</li>
<li>Cu&#xE1;ndo mostrar las notificaciones. Para que las notificaciones no resulten frustrantes, estas deben ser <a href="https://developers.google.com/web/fundamentals/engage-and-retain/push-notifications/" target="_blank">oportunas, relevantes y precisas</a>.</li>
</ol>
<hr>
<p>&#xA1;Enhorabuena! Has completado tu primera <em>PWA</em> partiendo de una aplicaci&#xF3;n web sin JavaScript. Recuerda que las aplicaciones web progresivas son parte de la Web y no necesitan seguir un patr&#xF3;n <em>single page application</em> ni incluir complejos <em>frameworks</em> JavaScript.</p>
<p>Este taller ha presentado el uso de <em>service workers</em>, notificaciones <em>push</em> y el manifiesto web pero debes de aplicar cada una de estas tecnolog&#xED;as por separado, pensando en las mejoras que desees incorporar a tu sitio web, en el marco de la mejora progresiva, para proporcionar una buena experiencia a todos tus usuarios y una mejor experiencia a los usuarios de la Web moderna.</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="../" class="navigation navigation-prev " aria-label="Previous page: Introduction">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="workshop.html#service-workers" class="navigation navigation-next " aria-label="Next page: Uso básico de service workers">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Introducción","level":"1.2","depth":1,"next":{"title":"Uso básico de service workers","level":"1.3","depth":1,"anchor":"#service-workers","path":"workshop/workshop.md","ref":"workshop/workshop.md#service-workers","articles":[{"title":"Creación del fichero y registro","level":"1.3.1","depth":2,"anchor":"#registering","path":"workshop/workshop.md","ref":"workshop/workshop.md#registering","articles":[]},{"title":"Instalación y activación del service worker","level":"1.3.2","depth":2,"anchor":"#installation","path":"workshop/workshop.md","ref":"workshop/workshop.md#installation","articles":[]},{"title":"Estrategias de caché","level":"1.3.3","depth":2,"anchor":"#cache-strategies","path":"workshop/workshop.md","ref":"workshop/workshop.md#cache-strategies","articles":[]},{"title":"Conclusión","level":"1.3.4","depth":2,"anchor":"#service-workers-conclusion","path":"workshop/workshop.md","ref":"workshop/workshop.md#service-workers-conclusion","articles":[]}]},"previous":{"title":"Introduction","level":"1.1","depth":1,"path":"README.md","ref":"README.md","articles":[]},"dir":"ltr"},"config":{"plugins":[],"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"language":"es","gitbook":"*"},"file":{"path":"workshop/workshop.md","mtime":"2017-07-23T09:39:27.000Z","type":"markdown"},"gitbook":{"version":"3.2.2","time":"2017-07-23T09:43:07.888Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

