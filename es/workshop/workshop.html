
<!DOCTYPE HTML>
<html lang="es" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>Primeros pasos con service workers · GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.2">
        
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
        <link rel="stylesheet" href="../styles/website.css">
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="workshop.html" />
    
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Escribe para buscar" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        <li class="header">Glitch</li>
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" >
            
                <span>
            
                    
                    Remezclando un proyecto
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" >
            
                <span>
            
                    
                    Las bases de Glitch
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="1.4" >
            
                <span>
            
                    
                    Recursos en Glitch
            
                </span>
            

            
        </li>
    

    
        
        <li class="header">Taller</li>
        
        
    
        <li class="chapter " data-level="2.1" data-path="workshop.html">
            
                <a href="workshop.html#1-uso-básico-de-service-workers">
            
                    
                    Primeros pasos con service workers
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.2" data-path="workshop.html">
            
                <a href="workshop.html#2-escribiendo-el-manifiesto-web">
            
                    
                    El manifiesto web
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.3" data-path="workshop.html">
            
                <a href="workshop.html#3-uso-básico-de-notificaciones-push">
            
                    
                    Notificaciones push
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">Guía del taller</li>
        
        
    
        <li class="chapter " data-level="3.1" >
            
                <span>
            
                    
                    Público
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="3.2" >
            
                <span>
            
                    
                    Duración
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="3.3" >
            
                <span>
            
                    
                    Equipamiento
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="3.4" >
            
                <span>
            
                    
                    Objetivo
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="3.5" >
            
                <span>
            
                    
                    Consideraciones adicionales
            
                </span>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Publicado con GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >Primeros pasos con service workers</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h2 id="1-uso-b&#xE1;sico-de-service-workers">1. Uso b&#xE1;sico de service workers</h2>
<p>Un <em>service worker</em> act&#xFA;a como un proxy de red ejecut&#xE1;ndose en el navegador: intercepta las peticiones HTTP que salen de nuestro sitio web hacia la red y puede contestar con cualquier tipo de contenido.</p>
<p>En esta primera lecci&#xF3;n, vamos a preparar nuestra aplicaci&#xF3;n para que funcione incluso sin conexi&#xF3;n a la red.</p>
<h3 id="creaci&#xF3;n-del-fichero-y-registro">Creaci&#xF3;n del fichero y registro</h3>
<p>Lo primero que vamos a hacer en Glitch es crear un nuevo archivo cuyo nombre ser&#xE1; <code>public/service-worker.js</code>. En &#xE9;l escribiremos el c&#xF3;digo que controla la intercepci&#xF3;n de las peticiones.</p>
<p><img src="." alt="En Glitch, al especificar el nombre, especificamos tambi&#xE9;n la ruta"></p>
<p>Visita tu aplicaci&#xF3;n haciendo click en <code>Show Live</code>, abre las herramientas de desarrollo y haz clic sobre la pesta&#xF1;a <em>Application</em>.</p>
<p>![La pesta&#xF1;a aplicaci&#xF3;n]</p>
<p>En la lista de la izquierda, haz clic en el item <em>Service Workers</em> para comprobar que no hay ninguno asociado a ese origen.</p>
<p>Recuerda que un origen no es lo mismo que un dominio. El origen es el protocolo junto con el nombre de dominio y el puerto. As&#xED;, <code>http://mozilla.org</code> y <code>https://mozilla.org</code> son or&#xED;genes distintos, como tambi&#xE9;n lo son <code>localhost:8000</code> y <code>localhost:3333</code>.</p>
<p>Un service worker debe registrarse desde el c&#xF3;digo del cliente. Edita <code>public/client.js</code> y a&#xF1;ade el siguiente c&#xF3;digo:</p>
<pre><code class="lang-js"><span class="hljs-keyword">if</span> (<span class="hljs-string">&apos;serviceWorker&apos;</span> <span class="hljs-keyword">in</span> navigator) {
  navigator.serviceWorker.register(<span class="hljs-string">&apos;/service-worker.js&apos;</span>)
  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&apos;&#xA1;Service Worker registrado!&apos;</span>); })
  .catch(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{ <span class="hljs-built_in">console</span>.error(<span class="hljs-string">&apos;Parece que hubo alg&#xFA;n problema:&apos;</span>, e)});
}
</code></pre>
<p>El condicional omite el proceso de registro si el navegador no soporta <em>service workers</em>. En caso de soportarlos, el m&#xE9;todo <a href="https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/register" target="_blank"><code>register</code></a> devuelve una promesa que, en caso de cumplirse, garantiza que el <em>service worker</em> est&#xE1; instal&#xE1;ndose.</p>
<p>Por supuesto, has de incluir el script en el punto de entrada HTML. En este caso edita <code>views/index.html</code> y antes de la etiqueta de cierre de la cabecera <code>&lt;/head&gt;</code>, a&#xF1;ade la siguiente l&#xED;nea:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/client.js&quot;</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<p>Cuando tu aplicaci&#xF3;n se actualice, comprueba que en la consola aparece el mensaje de que todo ha ido bien y que en la secci&#xF3;n <em>Service workers</em> de la pesta&#xF1;a <em>Application</em> se muestra el service worker como aparece en la captura siguiente:</p>
<p><img src="." alt="Si todo ha ido bien, el status del service worker indica _activated and is running_"></p>
<p>Un service worker s&#xF3;lo puede registrarse desde un origen seguro, que utilice <a href="https://es.wikipedia.org/wiki/Hypertext_Transfer_Protocol_Secure" target="_blank">HTTPS</a>. Puedes comprobar otros requerimientos r&#xE1;pidamente en la infograf&#xED;a <a href="https://github.com/delapuente/service-workers-101#service-workers-101" target="_blank"><em>Service Workers 101</em></a>.</p>
<h3 id="instalaci&#xF3;n-y-activaci&#xF3;n-del-service-worker">Instalaci&#xF3;n y activaci&#xF3;n del <em>service worker</em></h3>
<p>Vamos a modificar el <em>service worker</em> &#x2014;de ahora en adelante <em>SW</em>&#x2014; m&#xFA;ltiples veces y cada vez que lo hagamos, Glitch relanzar&#xE1; nuestra aplicaci&#xF3;n. Es conveniente, por tanto, activar la opci&#xF3;n <em>Update on reload</em> del men&#xFA; <em>Service Workers</em> del panel <em>Application</em> para garantizar que el <em>SW</em> se actualiza en cada recarga.</p>
<p><img src="." alt="Detalle del interruptor para activar la recarga al refrescar"></p>
<p>El panel de aplicaci&#xF3;n deber&#xED;a indicar que nuestro <em>SW</em> funciona correctamente aunque todav&#xED;a no haga nada. Durante la instalaci&#xF3;n, el <em>SW</em> pasa por tres estados (que puedes revisar en la inforgraf&#xED;a <a href="https://github.com/delapuente/service-workers-101#service-workers-101" target="_blank"><em>Service Workers 101</em></a>):</p>
<ol>
<li>Instalando: pensado para preparar la infraestructura necesaria para el funcionamiento del <em>SW</em>.</li>
<li>Activando: pensado para retirar la infraestructura de alguna versi&#xF3;n anterior del <em>SW</em>.</li>
<li>Activo: listo para interceptar peticiones a la red.</li>
</ol>
<p>A&#xF1;ade el siguiente c&#xF3;digo al fichero del <em>service worker</em> <code>public/service-worker.js</code>:</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> VERSION = <span class="hljs-number">1</span>;
<span class="hljs-keyword">var</span> PREFIX = <span class="hljs-string">&apos;__pwa-workshop&apos;</span>;
<span class="hljs-keyword">var</span> CACHE_NAME = <span class="hljs-string">`<span class="hljs-subst">${PREFIX}</span>-assets-v<span class="hljs-subst">${VERSION}</span>`</span>;
<span class="hljs-keyword">var</span> ASSETS = [
  <span class="hljs-string">&apos;https://cdn.glitch.com/aa6a5f34-4aee-4eae-807f-ca86f623e58a%2Fplus-black-symbol.svg?1499350618348&apos;</span>,
  <span class="hljs-string">&apos;https://cdn.glitch.com/aa6a5f34-4aee-4eae-807f-ca86f623e58a%2Ftick-sign.svg?1499363273037&apos;</span>,
  <span class="hljs-string">&apos;https://cdn.glitch.com/aa6a5f34-4aee-4eae-807f-ca86f623e58a%2Flike.svg?1499363275514&apos;</span>,
  <span class="hljs-string">&apos;https://cdn.glitch.com/aa6a5f34-4aee-4eae-807f-ca86f623e58a%2Fcloud-backup-up-arrow.svg?1499366672437&apos;</span>,
  <span class="hljs-string">&apos;https://fonts.googleapis.com/css?family=Poppins&apos;</span>,
  <span class="hljs-string">&apos;https://fonts.gstatic.com/s/poppins/v2/HUuNgGR31mqIHE6zs0BlBgLUuEpTyoUstqEm5AMlJo4.woff2&apos;</span>,
  <span class="hljs-string">&apos;/client.js&apos;</span>,
  <span class="hljs-string">&apos;/style.css&apos;</span>,
  <span class="hljs-string">&apos;/error-page.html&apos;</span>,
  <span class="hljs-string">&apos;/&apos;</span>
];

self.addEventListener(<span class="hljs-string">&apos;install&apos;</span>, event =&gt; {
  event.waitUntil(<span class="hljs-built_in">Promise</span>.all([addAssets(), self.skipWaiting()]));
});

self.addEventListener(<span class="hljs-string">&apos;activate&apos;</span>, event =&gt; {
  event.waitUntil(<span class="hljs-built_in">Promise</span>.all([clearOldCaches(), self.clients.claim()]));
});
</code></pre>
<p>En el contexto de un <em>service worker</em> o de cualquier otro <em>worker</em>, <code>self</code> hace referencia siempre al objeto global. Con <code>addEventListener</code> podemos suscribirnos a los cambios en el ciclo de vida del <em>SW</em>.</p>
<p>El m&#xE9;todo <a href="https://developer.mozilla.org/en-US/docs/Web/API/ExtendableEvent/waitUntil" target="_blank"><code>waitUntil</code></a> de los eventos <code>install</code> y <code>activate</code> permite extender las fases de instalaci&#xF3;n y activaci&#xF3;n respectivamente, hasta que la promesa pasada como par&#xE1;metro se resuelva.</p>
<p>Entre la instalaci&#xF3;n y la activaci&#xF3;n, el navegador espera a que todos los clientes actualmente controlados por un <em>service worker</em> se cierren, antes de activar el siguiente. Con el m&#xE9;todo <a href="https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerGlobalScope/skipWaiting" target="_blank"><code>skipWaiting</code></a> podemos acelerar el proceso evitando la espera del <em>SW</em>.</p>
<p>Durante la activaci&#xF3;n, utilizamos el m&#xE9;todo <a href="https://developer.mozilla.org/en-US/docs/Web/API/Clients/claim" target="_blank"><code>claim</code></a> para hacer que el <em>SW</em> intercepte todas las peticiones originadas en los clientes activos (pesta&#xF1;as ya abiertas, otros <em>workers</em>&#x2026;) a partir de ahora.</p>
<p>Aun no hemos escrito las funciones <code>addAssets</code> y <code>clearOldCaches</code>, por lo que el proceso de instalaci&#xF3;n falla en tiempo de ejecuci&#xF3;n y la instalaci&#xF3;n se interrumpe. Pod&#xE9;is ver los errores relacionados con la instalaci&#xF3;n del <em>SW</em> bajo el estado, en la vista <em>Service Workers</em>, en la pesta&#xF1;a <em>Application</em>.</p>
<p><img src="." alt="Detalle de los errores de instalaci&#xF3;n por la ausencia de las funciones"></p>
<p>Antes de continuar, <strong>borra los errores</strong> y luego a&#xF1;ade el siguiente listado con la implementaci&#xF3;n de las funciones que faltan:</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addAssets</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> self.caches.open(CACHE_NAME)
  .then(cache =&gt; cache.addAll(ASSETS));
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clearOldCaches</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> self.caches.keys()
  .then(allCaches =&gt; {
    <span class="hljs-keyword">return</span> allCaches.filter(cacheName =&gt; {
      <span class="hljs-keyword">var</span> isMine = cacheName.indexOf(PREFIX) === <span class="hljs-number">0</span>;
      <span class="hljs-keyword">var</span> isNotTheNewest = cacheName !== CACHE_NAME;
      <span class="hljs-keyword">return</span> isMine &amp;&amp; isNotTheNewest;
    });
  })
  .then(oldCaches =&gt; {
    <span class="hljs-keyword">return</span> oldCaches.map(cacheName =&gt; {
      <span class="hljs-keyword">return</span> self.caches.delete(cacheName);
    });
  })
  .then(deletingTasks =&gt; <span class="hljs-built_in">Promise</span>.all(deletingTasks));
}
</code></pre>
<p>Ls funci&#xF3;n <code>addAssets</code> acepta una lista de recursos (<em>assets</em>), y con el m&#xE9;todo <a href="https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage/open" target="_blank"><code>open</code></a>, abre una nueva cach&#xE9; (cre&#xE1;ndola si no exist&#xED;a) donde a&#xF1;adir estos recursos. Para ello utiliza el m&#xE9;todo <a href="https://developer.mozilla.org/en-US/docs/Web/API/Cache/addAll" target="_blank"><code>addAll</code></a> de la cach&#xE9;.</p>
<p>La lista de recursos <code>ASSETS</code> contiene los iconos de la aplicaci&#xF3;n, la hoja de estilos, el c&#xF3;digo JavaScript del cliente (exceptuando el <em>SW</em>), las fuentes, la p&#xE1;gina de error y el &#xED;ndice.</p>
<p>La funci&#xF3;n <code>clearOldCaches</code> obtiene todas los nombres de las caches en el origen con el m&#xE9;todo <a href="https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage/keys" target="_blank"><code>keys</code></a>, reconoce las propias y borra las antiguas con el m&#xE9;todo <a href="https://developer.mozilla.org/en-US/docs/Web/API/Cache/delete" target="_blank"><code>delete</code></a>.</p>
<p>Si todo ha ido bien, no deber&#xED;as ver nuevos errores bajo el estado del <em>service worker</em>. Si adem&#xE1;s haces click en el elemento <em>Cache storage</em>, deber&#xED;as poder ver un listado de las caches y su contenido (haz click en el icono de refrescar si no aparece nada). Prueba a cambiar el n&#xFA;mero de versi&#xF3;n para comprobar que el c&#xF3;digo funciona correctamente.</p>
<p>![Cache offline y su contenido]</p>
<h3 id="estrategias-de-cache">Estrategias de cache</h3>
<p>Gracias a las cach&#xE9;s sin conexi&#xF3;n (<a href="https://developer.mozilla.org/en-US/docs/Web/API/Cache" target="_blank"><em>Offline Caches</em></a>) tenemos los recursos para recrear la interfaz de usuario sin necesidad de estar conectados a la red, pero aun no le hemos dicho al <em>SW</em> cu&#xE1;ndo debe servir estos recursos. Por el momento, todas las peticiones a la red alcanzan la red.</p>
<p>Puedes ir al panel <em>Network</em> en las herramientas de desarrollador y activar el interruptor <em>Offline</em> para simular que no hay red. Realiza alguna acci&#xF3;n o recarga y ver&#xE1;s como la aplicaci&#xF3;n falla estrepitosamente.</p>
<p><img src="." alt="Detalle del interruptor offline que simula la ausencia de red"></p>
<p>Sin modificar una sola l&#xED;nea en el c&#xF3;digo de la UI, nuestra intenci&#xF3;n es crear una capa de red, en el <em>service worker</em>, que responda de forma diferente seg&#xFA;n el tipo de petici&#xF3;n y el estado de la conexi&#xF3;n.</p>
<p>Empieza a&#xF1;adiendo el siguiente listado, tras registrar el <em>listener</em> del evento <code>activate</code>:</p>
<pre><code class="lang-js">self.addEventListener(<span class="hljs-string">&apos;fetch&apos;</span>, event =&gt; {
  <span class="hljs-keyword">var</span> result = handleRequest(event.request);
  <span class="hljs-keyword">var</span> response = result[<span class="hljs-number">0</span>];
  <span class="hljs-keyword">var</span> completion = result[<span class="hljs-number">1</span>];
  event.respondWith(response);
  event.waitUntil(completion);
});
</code></pre>
<p>La funci&#xF3;n <code>handleRequest</code> ser&#xE1; la encargada de implementar esta capa de red y devolver&#xE1; una lista con dos promesas. El m&#xE9;todo <a href="https://developer.mozilla.org/en-US/docs/Web/API/FetchEvent/respondWith" target="_blank"><code>respondWith</code></a> consume la primera, que debe resolverse con un objeto del tipo <a href="https://developer.mozilla.org/en-US/docs/Web/API/Response" target="_blank"><code>Response</code></a> y ser&#xE1; entregado al navegador para que sirva de respuesta a la petici&#xF3;n. De nuevo, utilizaremos <a href="https://developer.mozilla.org/en-US/docs/Web/API/ExtendableEvent/waitUntil" target="_blank"><code>waitUntil</code></a> para extender la vida del <em>SW</em> hasta que la segunda promesa de la lista se resuelva.</p>
<p>Los <em>service workers</em> est&#xE1;n pensados para realizar una tarea concreta y cerrarse de forma que no consuman recursos innecesarios. Dada su naturaleza as&#xED;ncrona, no se puede determinar de antemano cu&#xE1;ndo un <em>service worker</em> ha terminado. Es por ello que utilizamos <code>waitUntil</code> con una promesa. Tal promesa expresa que todas las acciones que queremos realizar han terminado.</p>
<p>Por el mismo motivo, no se puede confiar en el estado global de un <em>service worker</em> dado que, tarde o temprano, el navegador eliminar&#xE1; al <em>SW</em> y el estado global se perder&#xE1;.</p>
<h4 id="estrategia-s&#xF3;lo-cach&#xE9;">Estrategia <em>s&#xF3;lo cach&#xE9;</em></h4>
<p>Antes de continuar, comprueba que has desactivado el modo <em>Offline</em> y refresca la pesta&#xF1;a.</p>
<p>Comencemos de forma sencilla. A&#xF1;ade el siguiente listado al final del fichero del <em>SW</em>:</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleRequest</span>(<span class="hljs-params">request</span>) </span>{
  <span class="hljs-keyword">if</span> (isAsset(request)) {
    <span class="hljs-keyword">return</span> only(fromCache(request));
  }
  <span class="hljs-keyword">return</span> only(fetch(request));
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isAsset</span>(<span class="hljs-params">request</span>) </span>{
  <span class="hljs-keyword">var</span> url = <span class="hljs-keyword">new</span> URL(request.url);
  <span class="hljs-keyword">return</span> !isIndex(request) &amp;&amp;
         (ASSETS.indexOf(url.href) &gt;= <span class="hljs-number">0</span> ||
         ASSETS.indexOf(url.pathname) &gt;= <span class="hljs-number">0</span>);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isIndex</span>(<span class="hljs-params">request</span>) </span>{
  <span class="hljs-keyword">var</span> url = <span class="hljs-keyword">new</span> URL(request.url);
  <span class="hljs-keyword">return</span> url.pathname === <span class="hljs-string">&apos;/&apos;</span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fromCache</span>(<span class="hljs-params">request</span>) </span>{
  <span class="hljs-keyword">return</span> self.caches.open(CACHE_NAME)
  .then(cache =&gt; cache.match(request));
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">only</span>(<span class="hljs-params">promise</span>) </span>{
  <span class="hljs-keyword">return</span> [promise, <span class="hljs-built_in">Promise</span>.resolve()];
}
</code></pre>
<p>Ve ahora a la pesta&#xF1;a <em>Network</em> y limpia los logs. Recarga el tab manualmente y observa los resultados en la lista de peticiones. Ver&#xE1;s como los recursos se sirven desde el <em>SW</em>:</p>
<p><img src="." alt="En la columna size se lee &quot;from service worker&quot; indicando que el recurso se ha servidor desde un service worker"></p>
<p>Date cuenta de que aunque se indique que el recurso se ha servido desde el <em>SW</em>, esto <strong>no significa que se haya servido desde una cach&#xE9;</strong>.</p>
<p>Si activas el modo <em>Offline</em> y recargas, ver&#xE1;s c&#xF3;mo la aplicaci&#xF3;n sigue fallando. Esto es porque el &#xED;ndice no se considera un recurso (<em>asset</em>) y, por tanto, no se sirve desde una cach&#xE9;.</p>
<p>Sin embargo, podr&#xED;as consultar la p&#xE1;gina de error <code>/error-page.html</code> dado que esta s&#xED; se considera un recurso y se servir&#xE1; desde la cach&#xE9;. Lo mismo ocurre con cualquier recurso que incluyeras en la variable <code>ASSETS</code>.</p>
<p>El c&#xF3;digo anterior se explica por s&#xED; mismo: si la petici&#xF3;n es un recurso, lo servimos desde la cach&#xE9; con la funci&#xF3;n <code>fromCache</code>. Si no, lo servimos desde la red con <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch" target="_blank"><code>fetch</code></a>. La nueva API fetch tiende a reemplazar la famosa interfaz <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest" target="_blank"><code>XMLHttpRequest</code></a> y adem&#xE1;s, es la &#xFA;nica forma de realizar una petici&#xF3;n desde un <em>SW</em>. Ninguna de las peticiones originadas en un <em>SW</em> ser&#xE1; jam&#xE1;s interceptada.</p>
<p>La funci&#xF3;n <code>fromCache</code> usa el m&#xE9;todo <a href="https://developer.mozilla.org/en-US/docs/Web/API/Cache/match" target="_blank"><code>match</code></a> de las cach&#xE9;s para buscar una respuesta a la petici&#xF3;n pasada como par&#xE1;metro.</p>
<p>Desactiva el modo <em>Offline</em> y recarga el &#xED;ndice antes de continuar.</p>
<h4 id="red-m&#xE1;s-actualizaci&#xF3;n-o-alternativa-offline">Red m&#xE1;s actualizaci&#xF3;n o alternativa offline</h4>
<p>Veamos ahora c&#xF3;mo tratar las acciones. Modifica la funci&#xF3;n <code>handleRequest</code> para que quede de la siguiente forma:</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleRequest</span>(<span class="hljs-params">request</span>) </span>{
  <span class="hljs-keyword">if</span> (isAsset(request)) {
    <span class="hljs-keyword">return</span> only(fromCache(request));
  }
  <span class="hljs-keyword">if</span> (isAction(request)) {
    <span class="hljs-keyword">var</span> offlinePage = isIndex(request) ? cachedIndex() : errorPage();
    <span class="hljs-keyword">return</span> fetchAndUpdateIndex(request, offlinePage);  
  }
  <span class="hljs-keyword">return</span> only(fetch(request));
}
</code></pre>
<p>En pocas palabras, si la petici&#xF3;n no es un recurso, pero es una operaci&#xF3;n, lo que queremos es que llegue a la red. De no haber red, queremos poder dar una alternativa sin conexi&#xF3;n. Esta alternativa depender&#xE1; de si estamos visitando la lista de recomendaciones o realizando una operaci&#xF3;n. En el primer caso devolveremos la lista m&#xE1;s actualizada desde la cach&#xE9;. En el segundo mostraremos una pantalla de error dando la opci&#xF3;n de volver a la lista. En caso de que la petici&#xF3;n no sea ni un recurso, ni una acci&#xF3;n, dejaremos que alcance la red normalmente.</p>
<p>A&#xF1;ade el siguiente listado al final del archivo:</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isAction</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> url = <span class="hljs-keyword">new</span> URL(request.url);
  <span class="hljs-keyword">return</span> url.pathname.indexOf(<span class="hljs-string">&apos;/recommendations&apos;</span>) === <span class="hljs-number">0</span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cachedIndex</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> fromCache(<span class="hljs-string">&apos;/&apos;</span>);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">errorPage</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> fromCache(<span class="hljs-string">&apos;/error-page.html&apos;</span>);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fetchAndUpdateIndex</span>(<span class="hljs-params">request, offlineAlternative</span>) </span>{
  <span class="hljs-keyword">var</span> done;
  <span class="hljs-keyword">var</span> completion = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(resolve =&gt; done = resolve);
  <span class="hljs-keyword">var</span> response = doRequest(request, offlineAlternative, done);
  <span class="hljs-keyword">return</span> [response, completion];

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doRequest</span>(<span class="hljs-params">request, offlineAlternative, done</span>) </span>{
    <span class="hljs-keyword">return</span> fetch(request)
    .then(response =&gt; {
      <span class="hljs-keyword">if</span> (!response.ok) {
        done();
        <span class="hljs-keyword">return</span> offlineAlternative;
      }
      updateIndex(response.clone()).then(done);
      <span class="hljs-keyword">return</span> response;
    })
    .catch(reason =&gt; {
      done();
      <span class="hljs-keyword">return</span> offlineAlternative;
    });
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateIndex</span>(<span class="hljs-params">response</span>) </span>{
  <span class="hljs-keyword">return</span> self.caches.open(CACHE_NAME)
  .then(cache =&gt; cache.put(<span class="hljs-string">&apos;/&apos;</span>, response));
}
</code></pre>
<p>La funci&#xF3;n <code>fetchAndUpdateIndex</code> implementa toda la l&#xF3;gica de cach&#xE9;. Respondemos con la alternativa sin conexi&#xF3;n cuando <code>fetch</code> falla o el servidor devuelve una respuesta <em>no OK</em>, lo que quiere decir que no est&#xE1; en el rango <a href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#2xx_Success" target="_blank"><code>2XX</code></a>. Si todo ha salido bien, usamos la respuesta para actualizar la entrada de cach&#xE9; que corresponde con el listado de recomendaciones (usando para ello el m&#xE9;todo <a href="https://developer.mozilla.org/en-US/docs/Web/API/Cache/put" target="_blank"><code>put</code></a>) y para responder a la petici&#xF3;n.</p>
<p>El cuerpo de una respuesta <strong>s&#xF3;lo puede utilizarse una vez</strong>, o se utiliza para representarse en el cliente o se utiliza para guardarse en la cach&#xE9;. Es por ello que copiamos la respuesta con <a href="https://developer.mozilla.org/en-US/docs/Web/API/Response/clone" target="_blank"><code>clone</code></a> antes de actualizar la cach&#xE9;.</p>
<p>Con estos cambios ya puedes pasar a modo <em>Offline</em> y probar a visitar el &#xED;ndice y a realizar alguna operaci&#xF3;n para alcanzar la p&#xE1;gina informativa.</p>
<h3 id="conclusi&#xF3;n">Conclusi&#xF3;n</h3>
<h2 id="2-escribiendo-el-manifiesto-web">2. Escribiendo el manifiesto web</h2>
<p>El manifiesto web es un fichero JSON con un objeto de <a href="https://w3c.github.io/manifest/#manifest-and-its-members" target="_blank">claves bien conocidas</a> que se enlaza desde nuestra p&#xE1;gina web de manera que el navegador obtenga la informaci&#xF3;n contenida y la use para aquellos fines que crea convenientes. Entre ellos, una mejor integraci&#xF3;n con el sistema como veremos a continuaci&#xF3;n.</p>
<p>No obstante, el manifiesto web tambi&#xE9;n puede ser utilizado por los buscadores web que beneficiarse de la informaci&#xF3;n contenida para mejorar la clasificaci&#xF3;n de estas p&#xE1;ginas web.</p>
<p>Crea un nuevo fichero en Glitch llamado <code>public/manifest.json</code> y a&#xF1;ade el siguiente contenido:</p>
<pre><code class="lang-js">{
  <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Recommendations&quot;</span>,
  <span class="hljs-string">&quot;short_name&quot;</span>: <span class="hljs-string">&quot;Recommendations&quot;</span>,
  <span class="hljs-string">&quot;description&quot;</span>: <span class="hljs-string">&quot;Keep track of everything you&apos;re recommended&quot;</span>,
  <span class="hljs-string">&quot;theme_color&quot;</span>: <span class="hljs-string">&quot;#FFDD60&quot;</span>,
  <span class="hljs-string">&quot;background_color&quot;</span>: <span class="hljs-string">&quot;#FFDD60&quot;</span>,
  <span class="hljs-string">&quot;display&quot;</span>: <span class="hljs-string">&quot;standalone&quot;</span>,
  <span class="hljs-string">&quot;icons&quot;</span>: [
    {
      <span class="hljs-string">&quot;src&quot;</span>: <span class="hljs-string">&quot;https://cdn.glitch.com/6f34aba2-54dc-445d-bebc-39255a1b8c6b%2Ficon196.png?1500627723764&quot;</span>,
      <span class="hljs-string">&quot;sizes&quot;</span>: <span class="hljs-string">&quot;196x196&quot;</span>,
      <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;image/png&quot;</span>
    }
  ]
}
</code></pre>
<p>Antes de profundizar en cada clave, enlaza el manifiesto con tu p&#xE1;gina web a&#xF1;adiendo el siguiente elemento HTML antes del cierre de la etiqueta <code>head</code>:</p>
<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;manifest&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/manifest.json&quot;</span>&gt;</span>
</code></pre>
<p>Las claves <code>name</code>, <code>short_name</code> y <code>description</code> son autoexplicativas. La clave <code>short_name</code> se prefiere cuando el espacio en pantalla para mostrar el nombre es limitado. Por ejemplo, en el caso del nombre bajo el icono en la pantalla de inicio.</p>
<p>Los campos <code>theme_color</code> y <code>background_color</code> colorean la interfaz de usuario del navegador. En particular, <code>background_color</code> se refiere al color de fondo del navegador mientras se carga la p&#xE1;gina web.</p>
<p>El campo <code>display</code> permite seleccionar una experiencia de navegaci&#xF3;n &#xF3;ptima, siendo <code>standalone</code> el valor que corresponde a la ausencia total de elementos de navegaci&#xF3;n.</p>
<p>La lista <code>icons</code> contiene una lista de iconos con entradas para las distintas resoluciones de pantalla y densidades de p&#xED;xeles.</p>
<p>Para una descripci&#xF3;n completa y con ejemplos de los campos del manifiesto, puedes consultar <a href="https://developer.mozilla.org/en-US/docs/Web/Manifest#Members" target="_blank">la p&#xE1;gina sobre el manifiesto web de la MDN</a>.</p>
<p>Visita tu aplicaci&#xF3;n desde el m&#xF3;vil usando Opera, Chrome o Samsung Internet, navegadores todos que ponen especial &#xE9;nfasis en la integraci&#xF3;n con el manifiesto y a&#xF1;ade tu aplicaci&#xF3;n a la pantalla de inicio:</p>
<p><img src="." alt="A&#xF1;adir la aplicaci&#xF3;n a la pantalla de inicio desde Chrome"></p>
<p>Observa la <em>splashpage</em> que genera Chrome gracias al color de fondo y la lista de iconos:</p>
<p><img src="." alt="Splashpage generada por Chrome"></p>
<p>Y f&#xED;jate en la ausencia de interfaz de usuario relacionada con el navegador:</p>
<p><img src="." alt="En el modo standalone no hay interfaz del navegador, como barras de navegaci&#xF3;n o herramientas"></p>
<p>Lo que tambi&#xE9;n se manifiesta en el cambiador de tareas:</p>
<p><img src="." alt="En el modo standalone, la p&#xE1;gina web aparece como un elemento distinto del cambiador de tareas"></p>
<p>Con estas modificaciones, tu sitio web ya entra en las definiciones de <em>progressive web apps</em> m&#xE1;s extendidas. No obstante recuerda que las <a href="https://medium.com/samsung-internet-dev/progressive-web-apps-are-a-toolkit-not-a-recipe-b2fd68613de5" target="_blank"><em>PWA</em> no son una receta sino una herramienta</a>.</p>
<p>Las herramientas de desarrollador de Chrome incluyen, en la pesta&#xF1;a <em>Application</em> y secci&#xF3;n <em>Manifest</em> una visualizaci&#xF3;n de los distintos campos del mismo.</p>
<h3 id="conclusi&#xF3;n">Conclusi&#xF3;n</h3>
<h2 id="3-uso-b&#xE1;sico-de-notificaciones-push">3. Uso b&#xE1;sico de notificaciones push</h2>
<p>Las notificaciones push tienen una interpretaci&#xF3;n doble: desde el punto de vista de red, una notificaci&#xF3;n push es una comunicaci&#xF3;n desde el servidor al cliente, iniciada por el servidor sin que el cliente haya realizado una petici&#xF3;n previa.</p>
<p><img src="." alt="Diagrama de una comunicaci&#xF3;n push del servidor al cliente"></p>
<p>Por otro lado, desde el punto de vista de la experiencia de usuario, una notificaci&#xF3;n push es un elemento de interfaz cuya finalidad es interrumpir levemente la actividad del usuario para comunicar cierta informaci&#xF3;n.</p>
<p><img src="." alt="Diagrama de una comunicaci&#xF3;n push del cliente al usuario"></p>
<p>No es extra&#xF1;o encontrar una tercera definici&#xF3;n que re&#xFA;ne estas dos y establece que cualquier comunicaci&#xF3;n iniciada en el servidor debe manifestarse ante el usuario. De hecho, los navegadores actuales fuerzan esta dependencia de forma que si no se muestra una notificaci&#xF3;n al usuario como respuesta a una notificaci&#xF3;n push proveniente del servidor, el navegador muestra una gen&#xE9;rica.</p>
<p>Algunos navegadores est&#xE1;s experimentando con permitir algunas notificaciones silenciosas, que no interrumpan la acci&#xF3;n del usuario.</p>
<p>De todas formas, conviene conocer la diferencia entre el protocolo de red y la met&#xE1;fora visual.</p>
<h3 id="estableciendo-la-comunicaci&#xF3;n-cliente-servidor">Estableciendo la comunicaci&#xF3;n cliente-servidor</h3>
<p><strong>Nota</strong>: configurar las notificaciones push para que funcionen con Chrome, Samsung Internet y Opera requiere conocer los valores <code>gcm_sender_id</code> y <code>gcm_api_key</code> de una aplicaci&#xF3;n <a href="https://firebase.google.com/" target="_blank">Firebase</a>. Aunque se te propocionar&#xE1;n unos valores de prueba durante el talle, puedes crear tu propia aplicaci&#xF3;n Firebase y consultar esta <a href="http://dev.tapjoy.com/faq/how-to-find-sender-id-and-api-key-for-gcm/" target="_blank">gu&#xED;a de TapJoy para saber d&#xF3;nde encontrarlos</a>.</p>
<hr>
<p>Comenzar a enviar notificaciones, sin el permiso expl&#xED;cito del usuario, podr&#xED;a resultar demasiado intrusivo. Es por ello que los navegadores obligan a pedir una subscripci&#xF3;n expl&#xED;citamente. En el momento en que el c&#xF3;digo del cliente pide una subscripci&#xF3;n, el navegador pide permiso al usuario para recibir notificaciones.</p>
<p>Edita el fichero <code>public/client.js</code> y modif&#xED;calo para que quede as&#xED;:</p>
<pre><code class="lang-js"><span class="hljs-keyword">if</span> (<span class="hljs-string">&apos;serviceWorker&apos;</span> <span class="hljs-keyword">in</span> navigator) {
  navigator.serviceWorker.register(<span class="hljs-string">&apos;/service-worker.js&apos;</span>)
  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">registration</span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&apos;&#xA1;Service Worker registrado!&apos;</span>);
  })
  .catch(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>{ <span class="hljs-built_in">console</span>.error(<span class="hljs-string">&apos;Parece que hubo alg&#xFA;n problema:&apos;</span>, e)});

  navigator.serviceWorker.ready.then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">registration</span>) </span>{
    <span class="hljs-keyword">return</span> subscribeToNotifications(registration.pushManager);
  });
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">subscribeToNotifications</span>(<span class="hljs-params">pushManager</span>) </span>{
  <span class="hljs-keyword">return</span> pushManager.getSubscription(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">subscription</span>) </span>{
    <span class="hljs-keyword">if</span> (subscription) {
      <span class="hljs-keyword">return</span> subscription;
    }
    <span class="hljs-keyword">return</span> pushManager.subscribe();
  })
  .then(sendDetailsToTheServer);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sendDetailsToTheServer</span>(<span class="hljs-params">subscription</span>) </span>{
  <span class="hljs-keyword">return</span> fetch(<span class="hljs-string">&apos;/recommendations/subscribe&apos;</span>, {
    method: <span class="hljs-string">&apos;POST&apos;</span>,
    headers: {
      <span class="hljs-string">&apos;Content-Type&apos;</span>: <span class="hljs-string">&apos;application/json&apos;</span>
    },
    body: <span class="hljs-built_in">JSON</span>.stringify({
      endpoint: subscription.endpoint,
      key: toBase64(subscription.key),
      auth: toBase64(subscription.auth)
    })
  });
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toBase64</span>(<span class="hljs-params">target</span>) </span>{
  <span class="hljs-keyword">return</span> !target ? <span class="hljs-string">&apos;&apos;</span> :
         btoa(<span class="hljs-built_in">String</span>.fromCharCode.apply(<span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(target)));
}
</code></pre>
<p>Edita tambi&#xE9;n el fichero <code>public/manifest.json</code> y a&#xF1;ade la clave <code>gcm_sender_id</code> con el valor que te proporcionar&#xE1;n en el taller o el que obtengas de tu aplicaci&#xF3;n Firebase.</p>
<p>Lo que estamos haciendo ahora es pedir al servicio de notificaciones del navegador que nos proporcione una subscripci&#xF3;n. Primero comprobamos que no exista ninguna anterior, que pudi&#xE9;ramos reciclar, con el m&#xE9;todo <a href="https://developer.mozilla.org/en-US/docs/Web/API/PushManager/getSubscription" target="_blank"><code>getSubscription</code></a> de la interfaz <a href="https://developer.mozilla.org/en-US/docs/Web/API/PushManager" target="_blank"><code>PushManager</code></a>. En caso de no existir, pediremos una nueva subscripci&#xF3;n con el m&#xE9;todo <a href="https://developer.mozilla.org/en-US/docs/Web/API/PushManager/subscribe" target="_blank"><code>subscribe</code></a>.</p>
<p>No siempre es bueno pedir permiso nada m&#xE1;s detectemos que no hay una subscripci&#xF3;n. Si trabaj&#xE1;ramos en un sitio web real, quiz&#xE1; debi&#xE9;ramos pedir una subscripci&#xF3;n cuando sepamos algo m&#xE1;s sobre el usuario. Igual cuando detectemos que no ha marcado ninguna recomendaci&#xF3;n durante semanas o, si se tratara de un blog, al detectar que el usuario termina de leer un art&#xED;culo o al finalizar una compra con &#xE9;xito si se tratase de un sitio de comercio <em>online</em>.</p>
<p>La subscripci&#xF3;n incluye una <em>URL</em> o <em>endpoint</em> al que realizaremos las peticiones de env&#xED;o de las notificaciones y unas claves necesarias para cifrar el contenido de las mismas.</p>
<p>F&#xED;jate en que la interfaz JavaScript que devuelve la subscripci&#xF3;n s&#xF3;lo se comunica con el cliente y es necesario que el cliente comunique a su servidor los detalles de la subscripci&#xF3;n, que es lo que se hace en la funci&#xF3;n <code>sendDetailsToTheServer</code>. Para ello utilizamos la interfaz <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch" target="_blank"><code>fetch</code></a> de la que ya hab&#xED;amos hablado anteriormente.</p>
<p>Edita ahora el fichero del servidor <code>server.js</code> para que guarde los detalles de la subscripci&#xF3;n. A&#xF1;ade la siguiente ruta justo antes de la declaraci&#xF3;n de <code>recommendations</code>:</p>
<pre><code class="lang-js">app.post(<span class="hljs-string">&apos;/subscribe&apos;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">request, response</span>) </span>{
  subscriptions[request.body.endpoint] = {
    key: request.body.key,
    auth: request.body.auth
  };
  request.sendStatus(<span class="hljs-number">201</span>);
});

<span class="hljs-keyword">var</span> subscriptions = {};
</code></pre>
<h3 id="enviando-notificaciones-a-los-clientes">Enviando notificaciones a los clientes</h3>
<p>&#xBF;Recuerdas la definici&#xF3;n de notificaci&#xF3;n push? En este punto vamos a implementar la primera interpretaci&#xF3;n. Es decir, la comunicaci&#xF3;n que ocurre desde el servidor hacia el cliente.</p>
<p>Para ello modifica el c&#xF3;digo del archivo <code>server.js</code> para que haga uso de la biblioteca <code>WebPush</code> que abstrae los detalles acerca de c&#xF3;mo enviar notificaciones a trav&#xE9;s de una interfaz m&#xE1;s amable. Comienza solicitando la biblioteca a&#xF1;adiendo la siguiente l&#xED;nea al comienzo del archivo:</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> webPush = <span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;web-push&apos;</span>);
webPush.setGCMAPIKey(<span class="hljs-string">&apos;XXXXXXXXX&apos;</span>); <span class="hljs-comment">// Reemplaza esta valor por el que te</span>
                                   <span class="hljs-comment">// proporcionen en el taller o por el que</span>
                                   <span class="hljs-comment">// obtengas de tu aplicaci&#xF3;n Firebase.</span>
</code></pre>
<p>Ahora modifica la declaraci&#xF3;n de <code>listener</code> para llamar al planificador de notificaciones:</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> listener = app.listen(process.env.PORT, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&apos;Your app is listening on port &apos;</span> + listener.address().port);
  scheduleNotification();
});

<span class="hljs-keyword">var</span> NOTIFICATION_PERIOD = <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>; <span class="hljs-comment">// 1 min</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">scheduleNotification</span>(<span class="hljs-params"></span>) </span>{
  setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">const</span> total = getUncheckedRecommendations();
    <span class="hljs-keyword">if</span> (total &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">const</span> summary = getSummary(total);
      <span class="hljs-built_in">Object</span>.keys(subscriptions).forEach(sendNotification.bind(<span class="hljs-literal">undefined</span>, summary));
    }
    scheduleNotification();
  }, NOTIFICATION_PERIOD);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getUncheckedRecommendations</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> recommendations.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">total, recommendation</span>) </span>{
    <span class="hljs-keyword">return</span> !recommendation.checked ? total + <span class="hljs-number">1</span> : total;
  }, <span class="hljs-number">0</span>);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSummary</span>(<span class="hljs-params">total</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-string">`You still have <span class="hljs-subst">${total}</span> unchecked recommendation<span class="hljs-subst">${total &gt; 1 ? &apos;s&apos; : &apos;&apos;}</span>`</span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sendNotification</span>(<span class="hljs-params">summary, endpoint</span>) </span>{
  <span class="hljs-keyword">const</span> subscription = {
    endpoint,
    keys: {
      auth: subscriptions[endpoint].auth,
      p256dh: subscriptions[endpoint].key
    },
    ttl: <span class="hljs-number">60</span> * <span class="hljs-number">60</span>
  };
  webPush.sendNotification(subscription, summary);
}
</code></pre>
<p>Las funciones <code>getUncheckedRecommendations</code> y <code>getSummary</code> no tienen misterio. La primera cuenta el n&#xFA;mero de recomendaciones que aun no hemos comprobado y la segunda compone un mensaje con este n&#xFA;mero.</p>
<p>La funci&#xF3;n <code>sendNotification</code> utiliza la biblioteca <code>webPush</code> para enviar una notificaci&#xF3;n mediante el m&#xE9;todo <a href="https://github.com/web-push-libs/web-push#sendnotificationpushsubscription-payload-options" target="_blank"><code>sendNotification</code></a>.</p>
<p>La constante <code>NOTIFICATION_PERIOD</code> establece cada cu&#xE1;nto se lanzar&#xE1; una nueva notificaci&#xF3;n. Cuando hayamos comprobado que todo funciona podemos elevar este n&#xFA;mero a 48 horas o el tiempo que consideremos oportuno.</p>
<h3 id="mostrando-la-notificaci&#xF3;n-al-usuario">Mostrando la notificaci&#xF3;n al usuario</h3>
<p>Es dif&#xED;cil comprobar que, efectivamente, la notificaci&#xF3;n ha alcanzado al cliente porque este no la trata, no hay a&#xFA;n una asociaci&#xF3;n entre recibir una notificaci&#xF3;n desde el servidor y usar la interfaz de usuario para mostrarla.</p>
<p>Esto lo arreglaremos en el <em>service worker</em>. Lo que haremos ser&#xE1; a&#xF1;adir un manejador para el evento <a href=""><code>push</code></a>. Modifica el fichero del <em>SW</em> <code>public/service-worker.js</code> y a&#xF1;ade esto al final del mismo:</p>
<pre><code class="lang-js">self.addEventListener(<span class="hljs-string">&apos;push&apos;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>{
  <span class="hljs-keyword">var</span> payload = event.data.text();
  event.waitUntil(self.registration.showNotification(<span class="hljs-string">&apos;Recommendations&apos;</span>, {
    body: payload
  }));
});
</code></pre>
<p>El m&#xE9;todo <a href=""><code>showNotification</code></a> mostrar&#xE1; la interfaz de usuario del sistema operativo asociada a una notificaci&#xF3;n. Como cuerpo de la notificaci&#xF3;n, utilizaremos el contenido de la notificaci&#xF3;n <em>push</em> que est&#xE1; disponible a trav&#xE9;s de la propiedad <a href="https://developer.mozilla.org/en-US/docs/Web/API/PushMessageData" target="_blank"><code>data</code></a> del evento.</p>
<h3 id="acci&#xF3;n-al-pulsar-en-la-notificaci&#xF3;n">Acci&#xF3;n al pulsar en la notificaci&#xF3;n</h3>
<p>Las notificaciones pueden recibirse sin tener la pesta&#xF1;a abierta e incluso, sin tener el navegador abierto. Por ello, al hacer click sobre la notificaci&#xF3;n ser&#xED;a conveniente recuperar la pesta&#xF1;a con la aplicaci&#xF3;n o, en su defecto, abrir una vista nueva.</p>
<p>El evento <a href="https://developer.mozilla.org/en-US/docs/Web/Events/notificationclick" target="_blank"><code>notificationclick</code></a> nos permite responder a la pulsaci&#xF3;n sobre una notificaci&#xF3;n. A&#xF1;ade el siguiente listado al final del <em>SW</em>:</p>
<pre><code class="lang-js">self.addEventListener(<span class="hljs-string">&apos;notificationclick&apos;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>{
  event.waitUntil(focusOnOpenTabOrNew());
});

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">focusOnOpenTabOrNew</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> self.clients.matchAll({ type: <span class="hljs-string">&apos;window&apos;</span> })
  .then(clientList =&gt; {
    <span class="hljs-keyword">if</span> (clientList.length &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span> clientList[<span class="hljs-number">0</span>].focus();
    }
    <span class="hljs-keyword">return</span> self.clients.openWindow(<span class="hljs-string">&apos;/&apos;</span>);
  });
}
</code></pre>
<p>Como en otras ocasiones, utilizamos <code>waitUntil</code> para mantener el <em>SW</em> corriendo hasta que todas las operaciones as&#xED;ncronas hayan terminado. Esta vez, utilizamos el m&#xE9;todo <a href="https://developer.mozilla.org/en-US/docs/Web/API/Clients/matchAll" target="_blank"><code>matchAll</code></a> para recuperar un listado completo de todas las ventanas/pesta&#xF1;as controladas por el <em>SW</em>. Si no hay ninguna, gracias al m&#xE9;todo <a href="https://developer.mozilla.org/en-US/docs/Web/API/Clients/openWindow" target="_blank"><code>openWindow</code></a> podemos abrir una pesta&#xF1;a nueva d&#xF3;nde indiquemos como par&#xE1;metro. Si existe alguna, bastar&#xE1; con darle el foco de atenci&#xF3;n mediante su m&#xE9;todo <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/focus" target="_blank"><code>focus</code></a>.</p>
<h3 id="conclusi&#xF3;n">Conclusi&#xF3;n</h3>
<p><a href="https://serviceworke.rs/web-push.html" target="_blank">https://serviceworke.rs/web-push.html</a></p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                
                <a href="workshop.html#2-escribiendo-el-manifiesto-web" class="navigation navigation-next navigation-unique" aria-label="Next page: El manifiesto web">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Primeros pasos con service workers","level":"2.1","depth":1,"next":{"title":"El manifiesto web","level":"2.2","depth":1,"anchor":"#2-escribiendo-el-manifiesto-web","path":"workshop/workshop.md","ref":"workshop/workshop.md#2-escribiendo-el-manifiesto-web","articles":[]},"previous":{"title":"Recursos en Glitch","level":"1.4","depth":1,"ref":"","articles":[]},"dir":"ltr"},"config":{"plugins":[],"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"language":"es","gitbook":"*"},"file":{"path":"workshop/workshop.md","mtime":"2017-07-21T19:01:48.000Z","type":"markdown"},"gitbook":{"version":"3.2.2","time":"2017-07-21T19:15:05.702Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

